[toc]

## å‰è¨€

> å­¦ä¹ è¦ç¬¦åˆå¦‚ä¸‹çš„æ ‡å‡†åŒ–é“¾æ¡ï¼šäº†è§£æ¦‚å¿µ->æ¢ç©¶åŸç†->æ·±å…¥æ€è€ƒ->æ€»ç»“æç‚¼->åº•å±‚å®ç°->å»¶ä¼¸åº”ç”¨"

## 01.å­¦ä¹ æ¦‚è¿°

- **å­¦ä¹ ä¸»é¢˜**ï¼š
- **çŸ¥è¯†ç±»å‹**ï¼š
  - [ ] âœ…Android/ 
    - [ ] âœ…01.åŸºç¡€ç»„ä»¶
    - [ ] âœ…02.IPCæœºåˆ¶
    - [ ] âœ…03.æ¶ˆæ¯æœºåˆ¶
    - [ ] âœ…04.ViewåŸç†
    - [ ] âœ…05.äº‹ä»¶åˆ†å‘æœºåˆ¶
    - [ ] âœ…06.Window
    - [ ] âœ…07.å¤æ‚æ§ä»¶
    - [ ] âœ…08.æ€§èƒ½ä¼˜åŒ–
    - [ ] âœ…09.æµè¡Œæ¡†æ¶
    - [ ] âœ…10.æ•°æ®å¤„ç†
    - [ ] âœ…11.åŠ¨ç”»
    - [ ] âœ…12.Groovy
  - [ ] âœ… Java/
    - [ ] âœ…01.åŸºç¡€çŸ¥è¯†
    - [ ] âœ…02.Javaè®¾è®¡æ€æƒ³
    - [ ] âœ…03.é›†åˆæ¡†æ¶
    - [ ] âœ…04.å¼‚å¸¸å¤„ç†
    - [ ] âœ…05.å¤šçº¿ç¨‹ä¸å¹¶å‘ç¼–ç¨‹
    - [ ] âœ…06.JVM
  - [ ] âœ… Kotlin/
    - [ ] âœ…01.åŸºç¡€è¯­æ³•
    - [ ] âœ…02.é«˜é˜¶æ‰©å±•
    - [x] âœ…03.åç¨‹å’Œæµ
- **å­¦ä¹ æ¥æº**ï¼šPosæœºç¬¬äºŒé˜¶æ®µMQTTå¿ƒè·³è¿æ¥æ¨¡å—è®¾è®¡
- **é‡è¦ç¨‹åº¦**ï¼šâ­â­â­â­â­ï¼ˆæ ¸å¿ƒåŸºç¡€ï¼‰  
- **å­¦ä¹ æ—¥æœŸ**ï¼š
- **è®°å½•äºº**ï¼š@panruiqi

### 1.1 å­¦ä¹ ç›®æ ‡

- äº†è§£æ¦‚å¿µ->æ¢ç©¶åŸç†->æ·±å…¥æ€è€ƒ->æ€»ç»“æç‚¼->åº•å±‚å®ç°->å»¶ä¼¸åº”ç”¨"

### 1.2 å‰ç½®çŸ¥è¯†

- [ ] çŠ¶æ€æµ
- [ ] åç¨‹



## 02.æ ¸å¿ƒæ¦‚å¿µ

### 2.1 æ˜¯ä»€ä¹ˆï¼Ÿ

- çŠ¶æ€æœºï¼ˆState Machineï¼‰æ˜¯ä¸€ç§è®¡ç®—æ¨¡å‹ï¼Œç”¨äºæè¿°å¯¹è±¡åœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…å¦‚ä½•å“åº”äº‹ä»¶å¹¶åœ¨ä¸åŒçŠ¶æ€é—´è½¬æ¢ã€‚

- å½¢å¼åŒ–å®šä¹‰ï¼š

  - ```
    çŠ¶æ€æœº = (çŠ¶æ€é›†åˆ, äº‹ä»¶é›†åˆ, è½¬æ¢å‡½æ•°, åˆå§‹çŠ¶æ€, ç»ˆæ­¢çŠ¶æ€é›†åˆ)
    
    S = {sâ‚, sâ‚‚, sâ‚ƒ, ...}     // çŠ¶æ€é›†åˆ
    E = {eâ‚, eâ‚‚, eâ‚ƒ, ...}     // äº‹ä»¶é›†åˆ  
    Î´: S Ã— E â†’ S              // è½¬æ¢å‡½æ•°
    sâ‚€ âˆˆ S                    // åˆå§‹çŠ¶æ€
    F âŠ† S                     // ç»ˆæ­¢çŠ¶æ€é›†åˆ
    ```

- å®ƒçš„å…³é”®åœ¨äºï¼š

  - è®°ä½å½“å‰å¤„äºä»€ä¹ˆçŠ¶æ€ï¼ˆæœ‰è®°å¿†ï¼‰

  - æ ¹æ®å¤–éƒ¨è¾“å…¥å†³å®šä¸‹ä¸€æ­¥è¡Œä¸ºï¼ˆæœ‰é€»è¾‘ï¼‰

  - æŒ‰ç…§é¢„å®šè§„åˆ™è¿›è¡ŒçŠ¶æ€åˆ‡æ¢ï¼ˆæœ‰è§„åˆ™ï¼‰

- ç”Ÿæ´»ä¸­çš„çŠ¶æ€æœºå®ä¾‹

  - ```
    // ğŸš— æ±½è½¦ç‚¹ç«ç³»ç»Ÿçš„çŠ¶æ€æœº
    sealed class CarState {
        object Parked : CarState()        // åœè½¦
        object EngineStarting : CarState() // å¯åŠ¨ä¸­
        object Idle : CarState()          // æ€ é€Ÿ
        object Driving : CarState()       // è¡Œé©¶
        object EngineOff : CarState()     // ç†„ç«
    }
    
    sealed class CarEvent {
        object TurnKey : CarEvent()       // è½¬é’¥åŒ™
        object PressGas : CarEvent()      // è¸©æ²¹é—¨
        object Pressbrake : CarEvent()   // è¸©åˆ¹è½¦
        object TurnOffEngine : CarEvent() // å…³é—­å¼•æ“
    }
    ```

### 2.2 è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

- é—®é¢˜1ï¼šå¤æ‚ä¸šåŠ¡æµç¨‹çš„ç®¡ç†

  - âŒ æ²¡æœ‰çŠ¶æ€æœºçš„æ··ä¹±ä»£ç ï¼š

  - ```
    class OrderProcessor {
        private var isCreated = false
        private var isPaid = false
        private var isShipped = false
        private var isDelivered = false
        private var isCancelled = false
        
        fun processPayment() {
            if (isCreated && !isPaid && !isCancelled && !isShipped) {
                // å¯ä»¥æ”¯ä»˜
                isPaid = true
            } else {
                // ä½†æ˜¯è¿™é‡Œçš„é€»è¾‘å¾ˆå®¹æ˜“å‡ºé”™
                throw IllegalStateException("Cannot pay in current state")
            }
        }
        
        fun cancelOrder() {
            if (!isShipped && !isDelivered) {
                // å¯ä»¥å–æ¶ˆï¼Œä½†éœ€è¦æ£€æŸ¥å¾ˆå¤šæ¡ä»¶
                isCancelled = true
                isPaid = false // é€€æ¬¾
            }
            // çŠ¶æ€ç®¡ç†å˜å¾—å¤æ‚ä¸”å®¹æ˜“å‡ºé”™
        }
    }
    ```

  - âœ… ä½¿ç”¨çŠ¶æ€æœºçš„æ¸…æ™°ä»£ç ï¼š

  - ```
    sealed class OrderState {
        object Created : OrderState()
        object Paid : OrderState()
        object Shipped : OrderState()
        object Delivered : OrderState()
        object Cancelled : OrderState()
    }
    
    class OrderStateMachine {
        fun transition(currentState: OrderState, event: OrderEvent): OrderState {
            return when (currentState to event) {
                OrderState.Created to OrderEvent.Pay -> OrderState.Paid //åˆ›å»ºè®¢å•çŠ¶æ€ï¼Œç»è¿‡æ”¯ä»˜è¡Œä¸ºï¼Œè½¬åŒ–æˆæ­£åœ¨æ”¯ä»˜çŠ¶æ€
                OrderState.Paid to OrderEvent.Ship -> OrderState.Shipped
                OrderState.Shipped to OrderEvent.Deliver -> OrderState.Delivered
                OrderState.Created to OrderEvent.Cancel -> OrderState.Cancelled
                OrderState.Paid to OrderEvent.Cancel -> {	//æ­£åœ¨æ”¯ä»˜çŠ¶æ€ï¼Œç»è¿‡å–æ¶ˆçš„è¡Œä¸ºï¼Œè½¬åŒ–ä¸ºå–æ¶ˆçŠ¶æ€
                    // æ‰§è¡Œé€€æ¬¾é€»è¾‘
                    OrderState.Cancelled
                }
                else -> throw IllegalStateException("Invalid transition")
            }
        }
    }
    ```

- é—®é¢˜2ï¼šå¹¶å‘ç¯å¢ƒä¸‹çš„çŠ¶æ€ä¸€è‡´æ€§

  - ```
    // âŒ çº¿ç¨‹ä¸å®‰å…¨çš„çŠ¶æ€ç®¡ç†
    class ConnectionManager {
        private var isConnecting = false
        private var isConnected = false
        
        fun connect() {
            if (!isConnecting && !isConnected) { // æ£€æŸ¥
                isConnecting = true               // è®¾ç½®
                // åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œè¿™é‡Œå¯èƒ½è¢«æ‰“æ–­
                doConnect()
                isConnecting = false
                isConnected = true
            }
        }
    }
    
    // âœ… çŠ¶æ€æœºä¿è¯åŸå­æ€§
    class ConnectionStateMachine {
        private val state = AtomicReference(ConnectionState.Disconnected)
        
        fun connect(): Boolean {
            return state.compareAndSet(
                ConnectionState.Disconnected,
                ConnectionState.Connecting
            )
        }
    }
    ```

- é—®é¢˜3ï¼šçŠ¶æ€è½¬æ¢çš„å¯é¢„æµ‹æ€§å’Œå¯æµ‹è¯•æ€§ï¼ŒçŠ¶æ€æœºæä¾›äº†ç¡®å®šæ€§çš„è¡Œä¸ºï¼š

  - ç»™å®šç›¸åŒçš„å½“å‰çŠ¶æ€å’Œäº‹ä»¶ï¼Œæ€»æ˜¯äº§ç”Ÿç›¸åŒçš„ç»“æœ

  - æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€è½¬æ¢éƒ½æ˜¯æ˜ç¡®å®šä¹‰çš„

  - ä¾¿äºå•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

### 2.3 åŸºæœ¬ç‰¹æ€§

- ç‰¹æ€§1ï¼šç¡®å®šæ€§

  - ```
    // å¯¹äºä»»ä½•ç»™å®šçš„(çŠ¶æ€, äº‹ä»¶)ç»„åˆï¼Œéƒ½æœ‰å”¯ä¸€ç¡®å®šçš„ä¸‹ä¸€ä¸ªçŠ¶æ€
    fun transition(state: State, event: Event): State {
        // åŒæ ·çš„è¾“å…¥ï¼Œæ°¸è¿œäº§ç”ŸåŒæ ·çš„è¾“å‡º
        return when (state to event) {
            State.A to Event.X -> State.B  // ç¡®å®šçš„è½¬æ¢
            State.B to Event.Y -> State.C  // ç¡®å®šçš„è½¬æ¢
            else -> state                  // æ— æ•ˆè½¬æ¢ä¿æŒåŸçŠ¶æ€
        }
    }
    ```

- ç‰¹æ€§2ï¼šçŠ¶æ€äº’æ–¥æ€§ï¼š

  - ```
    // ä»»ä½•æ—¶åˆ»åªèƒ½å¤„äºä¸€ä¸ªçŠ¶æ€
    sealed class MutualExclusiveState {
        object StateA : MutualExclusiveState()
        object StateB : MutualExclusiveState()
        object StateC : MutualExclusiveState()
        // ä¸èƒ½åŒæ—¶æ˜¯StateAå’ŒStateB
    }
    ```

- ç‰¹æ€§3ï¼šäº‹ä»¶é©±åŠ¨

  - ```
    class EventDrivenStateMachine {
        private var currentState: State = State.Initial
        
        // çŠ¶æ€æ”¹å˜åªèƒ½é€šè¿‡äº‹ä»¶è§¦å‘
        fun handleEvent(event: Event) {
            val newState = transition(currentState, event)
            if (newState != currentState) {
                onStateChange(currentState, newState)
                currentState = newState
            }
        }
        
        // ä¸å…è®¸ç›´æ¥è®¾ç½®çŠ¶æ€
        // private fun setState(state: State) // ä¸æä¾›æ­¤æ–¹æ³•
    }
    ```

- çŠ¶æ€è®°å¿†ç‰¹æ€§

  - ```
    class StatefulMachine {
        private var currentState: State = State.Initial
        private val stateHistory = mutableListOf<State>()
        
        fun getCurrentState(): State = currentState
        
        fun getStateHistory(): List<State> = stateHistory.toList()
        
        // çŠ¶æ€æœº"è®°ä½"å®ƒçš„å½“å‰çŠ¶æ€å’Œå†å²
    }
    ```

## 03.åŸç†æœºåˆ¶

### 3.1 è¿›ä¸€æ­¥æ€è€ƒï¼šçŠ¶æ€æœºçš„æ•°å­¦åŸºç¡€

- ```
  /**
   * æœ‰é™çŠ¶æ€è‡ªåŠ¨æœºçš„æ•°å­¦æ¨¡å‹
   * M = (Q, Î£, Î´, qâ‚€, F)
   * 
   * Q: æœ‰é™çŠ¶æ€é›†åˆ
   * Î£: æœ‰é™è¾“å…¥å­—æ¯è¡¨ï¼ˆäº‹ä»¶é›†åˆï¼‰  
   * Î´: è½¬æ¢å‡½æ•° Q Ã— Î£ â†’ Q
   * qâ‚€: åˆå§‹çŠ¶æ€
   * F: æ¥å—çŠ¶æ€é›†åˆ
   */
  class FiniteStateAutomaton<State, Event>(
      private val states: Set<State>,                    // Q
      private val events: Set<Event>,                    // Î£  
      private val transitionFunction: (State, Event) -> State?, // Î´
      private val initialState: State,                   // qâ‚€
      private val acceptStates: Set<State>               // F
  ) {
      
      private var currentState: State = initialState
      
      fun process(event: Event): Boolean {
          val nextState = transitionFunction(currentState, event)
          return if (nextState != null && nextState in states) {
              currentState = nextState
              true
          } else {
              false // æ‹’ç»æ— æ•ˆè½¬æ¢
          }
      }
      
      fun isInAcceptState(): Boolean = currentState in acceptStates
  }
  ```

### 3.2 è¿›ä¸€æ­¥æ€è€ƒï¼šçŠ¶æ€è½¬æ¢çš„å®ç°ç­–ç•¥

- ç­–ç•¥1ï¼šæŸ¥è¡¨æ³•

  ```
  class TransitionTableStateMachine {
      // ä½¿ç”¨äºŒç»´è¡¨å­˜å‚¨çŠ¶æ€è½¬æ¢
      private val transitionTable = mapOf(
          (State.A to Event.X) to State.B,
          (State.A to Event.Y) to State.C,
          (State.B to Event.X) to State.A,
          (State.B to Event.Y) to State.C,
          (State.C to Event.X) to State.A
      )
      
      fun transition(state: State, event: Event): State? {
          return transitionTable[state to event]
      }
  }
  ```

- ç­–ç•¥2ï¼šæ¡ä»¶åˆ†æ”¯æ³•

  ```
  class ConditionalStateMachine {
      fun transition(state: State, event: Event): State {
          return when (state) {
              State.A -> when (event) {
                  Event.X -> State.B
                  Event.Y -> State.C
                  else -> state
              }
              State.B -> when (event) {
                  Event.X -> State.A
                  Event.Y -> State.C
                  else -> state
              }
              State.C -> when (event) {
                  Event.X -> State.A
                  else -> state
              }
          }
      }
  }
  ```

- ç­–ç•¥3ï¼šç­–ç•¥æ¨¡å¼æ³•

  ```
  interface StateHandler {
      fun handle(event: Event): State
  }
  
  class StateA : StateHandler {
      override fun handle(event: Event): State {
          return when (event) {
              Event.X -> State.B
              Event.Y -> State.C
              else -> State.A
          }
      }
  }
  
  class StrategyBasedStateMachine {
      private val stateHandlers = mapOf(
          State.A to StateA(),
          State.B to StateB(),
          State.C to StateC()
      )
      
      fun transition(state: State, event: Event): State {
          return stateHandlers[state]?.handle(event) ?: state
      }
  }
  ```

### 3.3 è¿›ä¸€æ­¥æ€è€ƒï¼šçŠ¶æ€æœºçš„æ‰©å±•æ¨¡å‹

- å±‚æ¬¡çŠ¶æ€æœºï¼šåµŒå¥—çŠ¶æ€çš„çŠ¶æ€æœº

  ```
  // æ”¯æŒåµŒå¥—çŠ¶æ€çš„å¤æ‚çŠ¶æ€æœº
  sealed class HierarchicalState {
      object Disconnected : HierarchicalState()
      
      sealed class Connected : HierarchicalState() {
          object Authenticating : Connected()
          object Authenticated : Connected() {
              object Idle : Authenticated()
              object Working : Authenticated()
          }
      }
  }
  
  class HierarchicalStateMachine {
      private var currentState: HierarchicalState = HierarchicalState.Disconnected
      
      fun transition(event: Event): HierarchicalState {
          return when (currentState) {
              is HierarchicalState.Disconnected -> {
                  when (event) {
                      Event.Connect -> HierarchicalState.Connected.Authenticating
                      else -> currentState
                  }
              }
              is HierarchicalState.Connected.Authenticating -> {
                  when (event) {
                      Event.AuthSuccess -> HierarchicalState.Connected.Authenticated.Idle
                      Event.AuthFailed -> HierarchicalState.Disconnected
                      else -> currentState
                  }
              }
              // åµŒå¥—çŠ¶æ€çš„å¤„ç†
              is HierarchicalState.Connected.Authenticated -> {
                  handleAuthenticatedState(currentState, event)
              }
          }
      }
  }
  ```

- å¹¶å‘çŠ¶æ€æœºï¼š

  ```
  // å¤šä¸ªçŠ¶æ€æœºå¹¶è¡Œè¿è¡Œ
  class ConcurrentStateMachine {
      private val connectionStateMachine = ConnectionStateMachine()
      private val authenticationStateMachine = AuthenticationStateMachine()
      private val heartbeatStateMachine = HeartbeatStateMachine()
      
      fun handleEvent(event: Event) {
          // äº‹ä»¶å¯èƒ½å½±å“å¤šä¸ªçŠ¶æ€æœº
          when (event) {
              is NetworkEvent -> {
                  connectionStateMachine.handleEvent(event)
                  if (event is NetworkEvent.Disconnected) {
                      authenticationStateMachine.reset()
                      heartbeatStateMachine.stop()
                  }
              }
              is AuthEvent -> authenticationStateMachine.handleEvent(event)
              is HeartbeatEvent -> heartbeatStateMachine.handleEvent(event)
          }
      }
  }
  ```

  

## 04.åº•å±‚åŸç†

### 4.1 çŠ¶æ€å­˜å‚¨çš„ä¼˜åŒ–

```
// ä¼˜åŒ–1ï¼šä½¿ç”¨æšä¸¾è€Œéå¯†å°ç±»å‡å°‘å†…å­˜å ç”¨
enum class OptimizedState {
    DISCONNECTED,    // 4å­—èŠ‚å¼•ç”¨
    CONNECTING,      
    CONNECTED,
    ERROR
}

// ä¼˜åŒ–2ï¼šçŠ¶æ€å‹ç¼©å­˜å‚¨
class CompactStateMachine {
    // ä½¿ç”¨ä½æ©ç å­˜å‚¨å¤šä¸ªå¸ƒå°”çŠ¶æ€
    private var stateBits: Int = 0
    
    companion object {
        private const val CONNECTED_BIT = 1 shl 0      // 0001
        private const val AUTHENTICATED_BIT = 1 shl 1  // 0010  
        private const val HEARTBEAT_BIT = 1 shl 2      // 0100
        private const val ERROR_BIT = 1 shl 3          // 1000
    }
    
    fun isConnected(): Boolean = (stateBits and CONNECTED_BIT) != 0
    fun setConnected(connected: Boolean) {
        stateBits = if (connected) {
            stateBits or CONNECTED_BIT
        } else {
            stateBits and CONNECTED_BIT.inv()
        }
    }
}
```

### 4.2 è½¬æ¢å‡½æ•°çš„æ€§èƒ½ä¼˜åŒ–

```
// ä¼˜åŒ–1ï¼šé¢„è®¡ç®—è½¬æ¢è¡¨
class OptimizedTransitionTable {
    // ä½¿ç”¨æ•°ç»„æ›¿ä»£Mapï¼Œæé«˜æŸ¥æ‰¾é€Ÿåº¦
    private val transitionTable: Array<Array<Int>> = Array(StateCount) { Array(EventCount) { -1 } }
    
    init {
        // é¢„è®¡ç®—æ‰€æœ‰å¯èƒ½çš„è½¬æ¢
        transitionTable[State.A.ordinal][Event.X.ordinal] = State.B.ordinal
        transitionTable[State.A.ordinal][Event.Y.ordinal] = State.C.ordinal
        // ... å…¶ä»–è½¬æ¢
    }
    
    fun transition(state: State, event: Event): State? {
        val nextStateOrdinal = transitionTable[state.ordinal][event.ordinal]
        return if (nextStateOrdinal >= 0) {
            State.values()[nextStateOrdinal]
        } else null
    }
}

// ä¼˜åŒ–2ï¼šä½¿ç”¨å†…è”å‡½æ•°å‡å°‘å‡½æ•°è°ƒç”¨å¼€é”€
class InlineStateMachine {
    private var currentState: State = State.Initial
    
    inline fun <reified T : Event> handleEvent(event: T) {
        currentState = when (T::class) {
            ConnectEvent::class -> handleConnectEvent(event as ConnectEvent)
            DisconnectEvent::class -> handleDisconnectEvent(event as DisconnectEvent)
            else -> currentState
        }
    }
}
```

### 4.3 å†…å­˜å®‰å…¨å’Œçº¿ç¨‹å®‰å…¨çš„çŠ¶æ€æœº

```
// çº¿ç¨‹å®‰å…¨çš„çŠ¶æ€æœºå®ç°
class ThreadSafeStateMachine {
    private val stateLock = ReentrantReadWriteLock()
    private var _currentState: State = State.Initial
    
    val currentState: State
        get() = stateLock.readLock().withLock { _currentState }
    
    fun transition(event: Event): State {
        return stateLock.writeLock().withLock {
            val newState = computeNextState(_currentState, event)
            if (newState != _currentState) {
                _currentState = newState
                notifyStateChange(newState)
            }
            newState
        }
    }
}

// æ— é”çŠ¶æ€æœºï¼ˆä½¿ç”¨åŸå­æ“ä½œï¼‰
class LockFreeStateMachine {
    private val stateRef = AtomicReference(State.Initial)
    
    fun transition(event: Event): State {
        var currentState: State
        var newState: State
        
        do {
            currentState = stateRef.get()
            newState = computeNextState(currentState, event)
        } while (!stateRef.compareAndSet(currentState, newState))
        
        return newState
    }
}
```



## 05.æ·±åº¦æ€è€ƒ

### 5.1 å…³é”®é—®é¢˜æ¢ç©¶

- é—®é¢˜1ï¼šçŠ¶æ€çˆ†ç‚¸é—®é¢˜ï¼ˆState Explosionï¼‰å½“ç³»ç»Ÿå˜å¾—å¤æ‚æ—¶ï¼ŒçŠ¶æ€æ•°é‡å¯èƒ½å‘ˆæŒ‡æ•°çº§å¢é•¿ï¼š

  ```
  // âŒ çŠ¶æ€çˆ†ç‚¸çš„ä¾‹å­
  // å¦‚æœæœ‰3ä¸ªç‹¬ç«‹çš„Booleanå±æ€§ï¼Œå°±ä¼šäº§ç”Ÿ2Â³=8ä¸ªçŠ¶æ€
  sealed class ExplodedState {
      object DisconnectedUnauthenticatedIdle : ExplodedState()
      object DisconnectedUnauthenticatedWorking : ExplodedState()  
      object DisconnectedAuthenticatedIdle : ExplodedState()
      object DisconnectedAuthenticatedWorking : ExplodedState()
      object ConnectedUnauthenticatedIdle : ExplodedState()
      object ConnectedUnauthenticatedWorking : ExplodedState()
      object ConnectedAuthenticatedIdle : ExplodedState()
      object ConnectedAuthenticatedWorking : ExplodedState()
  }
  
  // âœ… è§£å†³æ–¹æ¡ˆï¼šçŠ¶æ€åˆ†è§£
  class CompositeStateMachine {
      private val connectionState = ConnectionStateMachine()    // 2ä¸ªçŠ¶æ€
      private val authenticationState = AuthStateMachine()     // 2ä¸ªçŠ¶æ€  
      private val workState = WorkStateMachine()               // 2ä¸ªçŠ¶æ€
      
      // æ€»çŠ¶æ€æ•° = 2 + 2 + 2 = 6ï¼Œè€Œä¸æ˜¯ 2Â³ = 8
  }
  ```

### 5.2 è®¾è®¡å¯¹æ¯”



## 06.å®è·µéªŒè¯

### 6.1 è¡Œä¸ºéªŒè¯ä»£ç 



### 6.2 æ€§èƒ½æµ‹è¯•





## 07.åº”ç”¨åœºæ™¯

### 7.1 æœ€ä½³å®è·µ



### 7.2 ä½¿ç”¨ç¦å¿Œ





## 08.æ€»ç»“æç‚¼

### 8.1 æ ¸å¿ƒæ”¶è·



### 8.2 çŸ¥è¯†å›¾è°±



### 8.3 å»¶ä¼¸æ€è€ƒ





## 



## 09.å‚è€ƒèµ„æ–™

1. [å®˜æ–¹æ–‡æ¡£ - Data Classes](https://kotlinlang.org/docs/data-classes.html)
2. [Kotlin in Action - Chapter 5](https://www.manning.com/books/kotlin-in-action)
3. [è§†é¢‘ï¼šData Classesæ·±æ½œ](https://youtu.be/xyz)


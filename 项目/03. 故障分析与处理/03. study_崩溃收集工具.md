[toc]

## 前言

> 学习要符合如下的标准化链条：了解概念->探究原理->深入思考->实践->总结提炼->底层实现->延伸应用"
>
> 故障分析是识别、定位和解决软件问题的系统化过程，是保障应用质量的关键环节。

## 01.学习概述

- **学习主题**：Android崩溃收集工具
- **知识类型**：
  - [ ] **知识类型**：
    - [ ] ✅Android/ 
      - [ ] ✅01.基础组件
      - [ ] ✅02.IPC机制
      - [ ] ✅03.消息机制
      - [ ] ✅04.View原理
      - [ ] ✅05.事件分发机制
      - [ ] ✅06.Window
      - [ ] ✅07.复杂控件
      - [ ] ✅08.性能优化
      - [ ] ✅09.流行框架
      - [ ] ✅10.数据处理
      - [ ] ✅11.动画
      - [ ] ✅12.Groovy
    - [ ] ✅音视频开发/
      - [ ] ✅01.基础知识
      - [ ] ✅02.OpenGL渲染视频
      - [ ] ✅03.FFmpeg音视频解码
    - [ ] ✅ Java/
      - [ ] ✅01.基础知识
      - [ ] ✅02.Java设计思想
      - [ ] ✅03.集合框架
      - [ ] ✅04.异常处理
      - [ ] ✅05.多线程与并发编程
      - [ ] ✅06.JVM
    - [ ] ✅ Kotlin/
      - [ ] ✅01.基础语法
      - [ ] ✅02.高阶扩展
      - [ ] ✅03.协程和流
    - [x] ✅ 故障分析与处理/
      - [ ] ✅01.基础知识
      - [ ] ✅02.崩溃收集工具
- **学习来源**： [03. 学习规划.md](03. 学习规划.md) 第一周规划
- **重要程度**：⭐⭐⭐⭐⭐
- **学习日期**：2025.07.14
- **记录人**：@panruiqi

### 1.1 学习目标

- 了解概念->探究原理->深入思考->总结提炼->底层实现->延伸应用"

### 1.2 前置知识

- [ ] 

## 02.核心概念

### 2.1 是什么？

想理解崩溃收集工具，就有先理解什么是崩溃？

- 崩溃是应用程序意外终止的现象，通常分为两大类：

  - Java崩溃：发生在Java/Kotlin代码层面，由未捕获的异常导致
    - NullPointerException（空指针异常）
    - IndexOutOfBoundsException（索引越界）
    - ClassCastException（类型转换异常）
    - OutOfMemoryError（内存溢出）

  - Native崩溃：发生在C/C++层面，通常更严重且难以调试
    - SIGSEGV (Segmentation fault)：内存访问违规
    - SIGABRT：程序中止信号
    - SIGILL：非法指令
    - SIGBUS：总线错误，通常是内存对齐问题
  - 我们常面对的是Java层的

那么崩溃收集工具是什么？

- 崩溃收集工具是一种能够自动捕获、记录、分析应用崩溃信息的系统，帮助开发者了解崩溃原因并快速修复。


### 2.2 解决什么问题？



### 2.3 基本特性



## 03.原理机制

### 3.1 进一步思考

崩溃收集的原理是什么？崩溃分为Java层和Native层。因此，崩溃收集的原理也分为两个

- Java层的崩溃收集基于Java的异常处理机制

  - ```
    应用启动
      │
      ▼
    设置全局未捕获异常处理器(UncaughtExceptionHandler)
      │
      ▼
    应用运行
      │
      ▼
    发生未捕获异常
      │
      ▼
    UncaughtExceptionHandler.uncaughtException()被调用
      │
      ▼
    收集设备信息、崩溃堆栈、应用状态
      │
      ▼
    保存信息到本地/上传到服务器
      │
      ▼
    应用重启或结束
    ```

- Native崩溃收集基于信号处理机制：

  - ```
    应用启动
      │
      ▼
    注册信号处理器(SIGSEGV, SIGABRT等)
      │
      ▼
    应用运行
      │
      ▼
    发生信号(如SIGSEGV)
      │
      ▼
    信号处理函数被调用
      │
      ▼
    生成内存dump、调用栈等信息
      │
      ▼
    保存信息到本地/上传到服务器
    ```

  - 核心实现通常需要用到JNI和NDK，通过signal()或sigaction()函数注册信号处理器

### 3.2 进一步思考

Java中异常体系我们了解了 [03. study_Java异常体系.md](03. study_Java异常体系.md) ，那请问他的整个异常的执行流是什么？

- ```
  异常发生
    │
    ▼
  JVM创建异常对象
    │
    ▼
  JVM查找异常处理器(try-catch块)
    │
    ▼
  若找到处理器→执行catch块
    │
    ▼
  若未找到→沿调用栈向上传播(栈展开)
    │
    ▼
  若栈顶也未处理→程序终止(崩溃)
  ```

- 本质就是捕捉到ex: Throwable，然后进行分发处理。处理逻辑中记录日志，异步上传等都是需要从ex中拿到相关信息去处理。

### 3.3 进一步思考

那这里的Throwable 是什么？

- Throwable介绍 ： 它是 Java 异常体系的顶层类（除Object外），所有的异常和错误都继承自它。当程序出现异常时，JVM 会创建一个 Throwable 实例或其子类实例，其中包含了异常发生的完整上下文信息。

- Throwable的核心结构：一个 Throwable 对象包含以下关键信息：

  - 异常消息(message)：描述异常原因的文本
  - 堆栈跟踪(stack trace)：异常发生时的方法调用链

  - 原因异常(cause)：导致当前异常的另一个异常（可选）

  - ```
    public class Throwable implements Serializable {
        // 异常消息
        private String detailMessage;
        
        // 原因异常
        private Throwable cause;
        
        // 堆栈跟踪元素数组，记录了调用链
        private StackTraceElement[] stackTrace;
        
        // 抑制的异常列表
        private List<Throwable> suppressedExceptions;
        
        // ...其他属性和方法
    }
    ```

- 堆栈跟踪？堆栈跟踪是崩溃分析的核心信息，它由一组 StackTraceElement 对象组成，每个元素包含:

  - 类名(className)：发生异常的类

  - 方法名(methodName)：发生异常的方法

  - 文件名(fileName)：源代码文件

  - 行号(lineNumber)：源代码行号

  这就是为什么崩溃日志能精确定位到出错位置的原因。

- 实例解析：

  - ```
    java.lang.NullPointerException: Attempt to invoke virtual method 'int android.view.View.getVisibility()' on a null object reference
        at com.ovopark.cloudpos.presentation.main.MainActivity.updateUI(MainActivity.kt:156)
        at com.ovopark.cloudpos.presentation.main.MainActivity.access$updateUI(MainActivity.kt:35)
        at com.ovopark.cloudpos.presentation.main.MainActivity$onCreate$1.onChanged(MainActivity.kt:78)
        at androidx.lifecycle.LiveData.considerNotify(LiveData.java:133)
        at androidx.lifecycle.LiveData.dispatchingValue(LiveData.java:151)
        at androidx.lifecycle.LiveData.setValue(LiveData.java:309)
        at androidx.lifecycle.MutableLiveData.setValue(MutableLiveData.java:50)
        at com.ovopark.cloudpos.presentation.main.MainViewModel$loadData$1.onResponse(MainViewModel.kt:45)
    ```

  - 这个 Throwable 中:

    - 类型: NullPointerException

    - 消息: "Attempt to invoke virtual method 'int android.view.View.getVisibility()' on a null object reference"

    - 发生位置: MainActivity.kt 第156行的 updateUI 方法

    - 调用链: 从网络响应处理一直到UI更新的完整路径

### 3.4 进一步思考

好的，我还是不理解底层的原理，我感觉还是有一份窗户纸，我们来模拟Java中异常的执行流吧。好，现在首先程序通过一个引用访问JVM中一个对象，但是这个对象实际以及没有了。然后呢？后续的流程是什么？

以空指针异常(NullPointerException)为例，我们来完整追踪从底层到应用层的执行流程

- 

### 3.5 进一步思考

那这里的Throwable 是什么？

## 04.底层原理



## 05.深度思考

### 5.1 关键问题探究



### 5.2 设计对比



## 06.实践验证

### 6.1 行为验证代码



### 6.2 性能测试





## 07.应用场景

### 7.1 最佳实践



### 7.2 使用禁忌





## 08.总结提炼

### 8.1 核心收获



### 8.2 知识图谱



### 8.3 延伸思考





## 09.参考资料

1. []()
2. []()
3. []()

## 其他介绍

### 01.关于我的博客

- csdn：http://my.csdn.net/qq_35829566

- 掘金：https://juejin.im/user/499639464759898

- github：https://github.com/jjjjjjava

- 邮箱：[934137388@qq.com]


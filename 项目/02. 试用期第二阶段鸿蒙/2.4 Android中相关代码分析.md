[toc]

- 入口位置：SettingActivity-----MessageSettingActivity.kt

## 01.MessageSettingActivity

### 1.1 视图逻辑

- 蛮容易搞懂的
  - ![image-20250519162310196](../../_pic_/image-20250519162310196.png)

### 1.2 代码逻辑

- addEvents:

  - ```
    override fun addEvents() {
            mBinding.ivBack.setOnClickListener { finish() }
            mBinding.tvNotificationSystem.setOnClickListener {
                NotificationManagerUtils.goToNotificationManager2(this@MessageSettingActivity)
            }
            //消息免打扰
            mBinding.llDisturb.setOnClickListener {
                val bundle = Bundle()
                bundle.putBoolean(Constants.Prefs.TRANSIT_BOOLEAN, true)
                readyGo(ReceiveMessageSettingActivity::class.java,bundle)
            }
            //接收新消息通知
            mBinding.llReceiveMessage.setOnClickListener {
                readyGo(ReceiveMessageSettingActivity::class.java)
            }
        }
    ```

  - | 点击控件                 | 行为描述                                                     |
    | ------------------------ | ------------------------------------------------------------ |
    | **ivBack**               | 直接关闭当前 Activity（`finish()`）                          |
    | **tvNotificationSystem** | 跳转系统通知管理页（`NotificationManagerUtils.goToNotificationManager2`） |
    | **llDisturb**            | 携带参数跳转至消息免打扰设置页（`bundle.putBoolean(TRANSIT_BOOLEAN, true)`） |
    | **llReceiveMessage**     | 无参跳转至接收新消息通知设置页                               |

- initViews：沉浸式状态栏设计

  - ```
    ImmersionBar.with(this)
        .fitsSystemWindows(true)
        .statusBarColor(R.color.back_page)
        .statusBarDarkFont(true)
        .navigationBarColor(R.color.white)
        .navigationBarDarkIcon(true)
        .init()
    
    ```

  - 视觉规范：

    - 状态栏颜色与主界面一致（`R.color.back_page`）
    - 导航栏保持白色背景+深色图标

  - **适配原理**：通过 [ImmersionBar](https://github.com/gyf-dev/ImmersionBar) 库动态修改系统栏属性

- 通知状态动态更新

  - ```
    override fun onResume() {
        super.onResume()
        isOpenNotification = NotificationManagerCompat.from(mContext).areNotificationsEnabled()
        // 根据状态更新UI
        if (isOpenNotification) {
            // 启用状态UI配置
            mBinding.flNotificationStatus.background = ... 
            mBinding.tvLossWarning.visibility = View.GONE
            // 其他元素样式调整
        } else {
            // 禁用状态UI配置
            mBinding.flNotificationStatus.background = ...
            mBinding.tvLossWarning.visibility = View.VISIBLE
        }
    }
    ```

  - **关键API**：`NotificationManagerCompat.areNotificationsEnabled()` 检测系统通知总开关

  - UI策略：

    - **启用状态**：隐藏警告提示，使用灰色系降低视觉优先级
    - **禁用状态**：显示黄色警示文字，引导用户操作

## 02. 跳转系统通知管理页

- `NotificationManagerUtils.goToNotificationManager2(this@MessageSettingActivity)`

- 其实就是启动一个系统的Activity：

  - ```
    fun goToNotificationManager2(mContext: Context) {
            val intent = Intent()
            try {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    intent.action = Settings.ACTION_APP_NOTIFICATION_SETTINGS
                    //这种方案适用于 API 26, 即8.0（含8.0）以上可以用
                    intent.putExtra(Settings.EXTRA_APP_PACKAGE, mContext.packageName)
                    intent.putExtra(Settings.EXTRA_CHANNEL_ID, mContext.applicationInfo.uid)
                } else {
                    //这种方案适用于 API21——25，即 5.0——7.1 之间的版本可以使用
                    intent.putExtra("app_package", mContext.packageName)
                    intent.putExtra("app_uid", mContext.applicationInfo.uid)
                }
                mContext.startActivity(intent)
            } catch (e: Exception) {
                intent.action = Settings.ACTION_APPLICATION_DETAILS_SETTINGS
                intent.data = Uri.fromParts("package", mContext.packageName, null)
                mContext.startActivity(intent)
            }
        }
    ```

- 这个应该不用自己写。

## 03.ReceiveMessageSettingActivity_免打扰和消息设置页面

- 继承关系：

  - ```
    class ReceiveMessageSettingActivity :
        BaseMvpBindingActivity<IReceviceMessgaeSettingView, ReceviceMessageSettingPresenter, ActivityReceiveMessageSettingBinding>(),
        IReceviceMessgaeSettingView 
    ```

  - 继承自BaseMvpBindingActivity，是MVP结构，对应的View是IReceviceMessgaeSettingView；Presenter是ReceviceMessageSettingPresenter；ViewBinding是ActivityReceiveMessageSettingBinding；

  - 实现了IReceviceMessgaeSettingView接口

### 3.1 视图逻辑：

- 线性垂直布局，包含三个部分，上方的toolbar，中间的TextView，下方的RecyclerView
  - ![image-20250519165018949](../../_pic_/image-20250519165018949.png)

- RecyclerView中子条目视图：
  - LinearLayout中一个TextView，一个ImageView
  - ![image-20250519165754030](../../_pic_/image-20250519165754030.png)

### 3.2 代码逻辑

- onCreate阶段：先处理当前的onCreate事件，然后调用父类的。

  - ```
        @Override
        protected void onCreate(Bundle savedInstanceState) {
    
            mContext = this;
            presenter = createPresenter();
            getPresenter().attachView((V) this);
            getPresenter().setContext(getApplicationContext());
            getPresenter().created();
    
            Intent intent = getIntent();
            if (intent != null) {
                Bundle bundle = intent.getExtras();
                if (bundle != null) {
                    getIntentData(bundle);
                }
            }
            super.onCreate(savedInstanceState);
        }
    ```

  - 创建Presenter，将其与View关联。然后解析传递的Bundle

  - 这里的getIntentData是如下，获取isDistrub

    - ```
          override fun getIntentData(bundle: Bundle) {
              isDisturb = bundle.getBoolean(Constants.Prefs.TRANSIT_BOOLEAN)
          }
      ```

  - 这个数据来源是MessageSettingActivity

    - ```
      //消息免打扰
      mBinding.llDisturb.setOnClickListener {
          val bundle = Bundle()
          bundle.putBoolean(Constants.Prefs.TRANSIT_BOOLEAN, true)
          readyGo(ReceiveMessageSettingActivity::class.java,bundle)
      }
      //接收新消息通知
      mBinding.llReceiveMessage.setOnClickListener {
          readyGo(ReceiveMessageSettingActivity::class.java)
      }
      ```

    - 他有两个点击事件，复用这一个页面，两者通过传递的Bundle进行区分。

- initView阶段：位于BaseActivity中的onCreate内部

  - 动态界面设置：通过 `isDisturb` 布尔值控制两种显示模式：

  - ```
    if (isDisturb) {
      // 勿扰模式界面
      title = getString(R.string.msg_disturb_setting)
      binding.tvTip.text = getString(R.string.turn_off_notification_bar_no_pushed_message_receive_no_affecte)
    } else {
      // 正常模式界面
      title = getString(R.string.receive_message_setting)
      binding.tvTip.text = getString(R.string.turn_off_no_message_receive_missed_messages_cannot_recovered)
    }
    
    ```

  - RecyclerView配置：创建 `FristMsgSettingAdapter` 并定义点击事件：

  - ```
    adapter = FristMsgSettingAdapter(this) { position ->
      val bundle = Bundle().apply {
        putBoolean(Constants.Prefs.TRANSIT_BOOLEAN, isDisturb)
        putSerializable(Constants.Prefs.TRANSIT_LIST, adapter.mList[position])
      }
      readyGo(SecondReceiveMessageSettingActivity::class.java, bundle)
    }
    ```

- onResume阶段

  - 每次界面可见时，刷新数据

    - ```
      override fun onResume() {
          super.onResume()
          presenter.getUserMessageConfig(this) // 每次界面可见时刷新数据
      }
      ```

  - 数据刷新流程：网络请求获取数据

    - ```
      MessageApi.instance.getMessageCofig(params, object : OnResponseCallback<...>() {
          override fun onSuccess(list) { view?.getMessageConfig(list) }       // 成功
          override fun onSuccessError(code, msg) { view?.getFailureMsg(msg) }// 业务错误
          override fun onFailure(code, msg) { view?.getFailureMsg(msg) }     // 网络错误
      })
      ```

  - 成功时刷新数据：getMessageConfig对应的是这个

    - ```
      public void refreshList(List<T> list) {
          mList.clear();
          mList.addAll(list);
          notifyDataSetChanged(); // 全局刷新
      }
      ```

- 子视图逻辑：

  - mList数据类型：

    - ```
      MessageConfigBean
      ├─ messageTypeId: Int          // 主分类ID
      ├─ name: String                // 分类名称
      ├─ childList: MutableList<Child>  // 子项列表
      └─ 状态标记 (勿扰/接收/重要性)
      
      Child
      ├─ messageTypeId: Int          // 当前项ID
      ├─ parentMessageTypeId: Int    // 父级ID
      ├─ childList: MutableList<Child>?  // 嵌套子项
      └─ 9个业务状态字段
      
      ```

    - ```
      /**
       * 创建人：yaoao
       * 创建日期：2024/6/15.8:27
       * 描述：
       * 修改人：
       * 迭代版本：
       * 迭代说明：
       */
      data class MessageConfigBean(
          val childList: MutableList<Child>,
          val messageTypeId: Int,
          val name: String,
          val noDisturbingFlag: Int,
          val receiveMessageFlag: Int,
          val importanceFlag: Int
      ):java.io.Serializable
      
      data class Child(
          val childList: MutableList<Child>?,
          val importanceFlag: Int,
          val messageTypeId: Int,
          val name: String,
          var noDisturbingFlag: Int,
          val parentMessageTypeId: Int,
          var receiveMessageFlag: Int,
          val topFlag: Int,
          val webMessageOpenFlag: Int,
          val code: String
      ):java.io.Serializable
      ```

  - 点击事件：

    - 传递数据，跳转至二级页面

    - ```
       // 传递当前是否处于勿扰模式的布尔值
       bundle.putBoolean(Constants.Prefs.TRANSIT_BOOLEAN, isDisturb)
       // 从适配器的数据源中按位置索引获取对应数据对象
       bundle.putSerializable(Constants.Prefs.TRANSIT_LIST, adapter.mList[position])
       // 携带参数跳转到新的 Activity
       readyGo(SecondReceiveMessageSettingActivity::class.java, bundle)
      ```

    - 
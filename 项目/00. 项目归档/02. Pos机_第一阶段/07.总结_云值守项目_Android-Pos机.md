[toc]

## **01.项目背景与目标（Why）**

### 1.1 **项目定位**

- 类型：企业级智能零售解决方案
- 目标场景：
  - **用户侧**：无人值守商店的自助购物全流程（扫码→支付→出店），音视频通话求助。
  - **商户侧**：
    - 商户为什么选择这个？很简单，降低人力成本，优化经营决策，优化用户体验啊。雇员一个是5000，两个是一万。同时它还没有大数据分析和AI决策帮助他进行经营决策的处理。以及没有巡店机器人可以快速响应用户询问，优化用户体验。
    - 降低人力成本，同时还能保证门店的正常经营管理，最好还能一定程度优化用户体验，也希望可以通过用户行为数据来优化自己的经营决策。远程门店管理（调控商品价格等）、实时数据监控（查看订单信息，用户扫码商品路径，付款异常状态等）、自动化运营干预（产生异常付款可以远程锁门，也可以远程响应用户求助）。
  - **公司侧**：零售大数据分析、AI决策支持系统（通过用户行为数据为商户侧提供经营决策辅助）
  - 后续还有巡店机器人，响应用户的询问，比如商品在哪？价格多少，我目前感冒，您建议我使用什么药品等等。
- 为什么做这个：
  - 微店做这个，一年净利润1个亿。

### 1.2 **POS机的角色定位**：

- 作为**云值守生态的物理交互中枢**，承担三大核心职能：
  - 面向用户，这是最关键最核心的部分：
    - 商品扫码识别 → 聚合支付（微信/支付宝/银行卡） → 动态出店码生成
    - **扩展模块**：用户求助系统（音视频通话）
  - **数据采集终端**：
    - 实时上传：用户行为流（停留时长/扫码路径）、交易流水、异常事件。
    - 其中用户行为流可以充当零售大数据分析的数据源。交易流水，异常事件等可以帮助商户侧进行自动化运营干预，实时数据监控
    - 比如：用户频繁扫码一个商品，但是又频繁取消，说明用户有需求，但是存在什么顾虑。通过数据分析，我们这边判断是价格偏高，建议门店适当调整价格，他们执行后，这个商品的销量果然是增长了很多，数据上好像是200%。
  - 指令执行器：
    - 接收云端指令：价格更新/商品下架 → 同步至POS界面
    - 联动嵌入式设备：展示出门码，扫码触发门禁开关

## **02. 技术架构设计（How）**

### 2.1 **整体架构模式**

- **模式选择**：MVVM架构
- **选择原因**：
  - 解耦性强，比如：UI层，只需要订阅流，不关心如何和网络进行数据交互，流中状态的变更被他察觉，那它就会相应的改变UI显示。
  - 可测试性（独立测试 Domain 层）
  - 扩展性强，比如：我后续来了新的需求，也不算，就是它一直没沟通好实现方式，因为要等待这个是否入主线。就是登录模块，假如说是MVC，那我要该的代码蛮多的，内部设计是死的，我改这个很可能会涉及到之前代码的修改。但是如果是MVVM，添加model，API，依赖注入，构建仓库层，添加case，然后ViewModel中调用一下，根据结果改变自己流的状态，UI订阅一下就好。层次明晰，更改容易。很少影响到原有代码逻辑。

### 2.2 **模块化设计**

- **模块拆分**：按功能划分模块，包含如下：
- Splash启动块：联网校验本地Token的有效性，如果有效，跳转到MainActivity中，如果无效，跳转到LoginActivity。加载过程中显示加载的进度条。
- Login登陆块：
  - 之前：显示二维码，根据MAC地址生成。用户扫码，触发Model更新，被分配新的token，最开始打算是WebSocket，然后后面更改为http轮询（为了加快开发流程）
  - 现在：传输MAC地址作为参数，通过http获取返回的token。直接将设备mac绑定到后端数据库，将这些设备加入主线设备管理中。
- Main购物车块：
  - 显示请扫码加购视图，提示用户扫码商品。
  - 商品列表视图，是一个RecyclerView，存放扫码商品。
  - 用户通过扫码枪扫码商品69码，向后端查询商品数据，显示在UI弹窗中，并存放到商品列表中
  - 用户点击 - / + 去增减商品，清空按钮清空购物车。同时+ - 清空操作，扫码操作等任何引起商品列表发生变化的操作都会调用计算价格的后端接口，实时更新总价格。
  - 用户清空商品列表后显示请扫码加购视图，隐藏商品列表视图。
  - 用户点击结算，跳转到结算页面
- Payment支付模块：
  - 显示请扫描付款的视图
  - 用户通过扫码枪扫码微信付款码，向后端发送支付请求，返回支付结果，显示支付成功的视图。
  - 支付成功后，想后端发起拉取出店码的请求，显示在屏幕上

## **03. 核心技术实现（What）**

### 3.1 **UI 层关键技术**

- **传统视图**：View Binding + 自定义 View 优化（避免过度绘制）
- 通过订阅ViewModel中StateFlow来实现UI的更新。
- 接受到操作后调用ViewModel中相关方法触发仓库层操作。
- 购物车和付款页比较特别，需要处理扫码输入事件，因此他们需要扫码模块支持

### 3.2 扫码模块设计

- ScanInputManager：扫码输入管理器

  - 全局唯一单例模式，只负责硬件输入处理，不处理业务逻辑。

  - onKeyDown时调用它，他有一个输入缓冲区，stringBuilder。处理输入事件

  - 当检测到enter事件时，将其通过下面发送出去

    - ```
       data class ScanData(
           val barcode: String,
           val timestamp: Long
       )
      
      _barcodeScanned = MutableSharedFlow<ScanData> 
      val barcodeScanned: SharedFlow<ScanData> = _barcodeScanned.asSharedFlow()
      
      val emitResult = _barcodeScanned.tryEmit(scanData)
      ```

      

#### 2. **数据流管理**

- **状态管理**：
  - `StateFlow`/`SharedFlow`（响应式更新 UI）
  - 结合 `Lifecycle.repeatOnLifecycle` 避免泄漏
- **依赖注入**：Dagger/Hilt 实现解耦（举例：注入 `Repository` 到 `ViewModel`）

#### 3. **网络与数据层**

- **网络库**：Retrofit + Kotlin Coroutines
  - 请求封装：统一处理错误码、Token 刷新
- **数据缓存策略**：
  - 三级缓存（内存 `Caffeine` → 磁盘 `Room` → 网络）
  - 数据新鲜度控制（`RemoteMediator` 实现分页缓存）

#### 4. **异步处理**

- **协程应用**：
  - 用 `CoroutineScope` 管理生命周期
  - 结构化并发取消任务
- **线程优化**：避免主线程阻塞（使用 `Dispatchers.IO` 调度耗时操作）

#### 5. **性能优化**

- **启动优化**：
  - 异步初始化（`App Startup` 库）
  - 延迟加载非关键组件
- **内存优化**：
  - `LeakCanary` 监控泄漏
  - 图片加载优化（`Coil`/`Glide` 的磁盘缓存策略）
- **渲染优化**：
  - 使用 `RecyclerView` 的 `DiffUtil` 减少无效刷新
  - 过度绘制检测（GPU 渲染模式分析）

------

## **04. 质量保障（Quality）**

1. **测试策略**
   - 单元测试：JUnit + MockK 测试 `ViewModel`/`UseCase`
   - UI 测试：Espresso 模拟用户操作
   - 快照测试：使用 `TestRule` 验证 Compose UI 状态
2. **监控与稳定性**
   - 崩溃监控：Firebase Crashlytics
   - 性能监控：Jetpack Macrobenchmark 检测帧率/启动耗时
3. **持续集成**
   - CI/CD 流程（GitHub Actions/Jenkins 自动化构建、测试、发布）

------

## **05. 难点与解决方案（突出技术深度）**

> ▶️ **示例回答结构**：
> **问题**：列表页快速滑动时出现卡顿
> **分析**：主线程频繁解析 JSON + 图片加载阻塞
> **解决**：
>
> 1. 改用 `Paging3` 分页加载数据
> 2. 图片加载添加滚动优先级控制（`Glide.setPauseOnScroll`）
> 3. JSON 解析迁移到后台线程（使用 `withContext(Dispatchers.Default)`）
>    **结果**：帧率从 45 FPS 提升至稳定 60 FPS

------

## **06. 技术选型对比（展示决策能力）**

| **场景** | 选项A  | 选项B       | **最终选择** | **原因**                   |
| :------- | :----- | :---------- | :----------- | :------------------------- |
| 异步框架 | RxJava | Kotlin Flow | ✅ Flow       | 协程原生支持、更简洁       |
| 依赖注入 | Koin   | Dagger Hilt | ✅ Hilt       | 官方支持、编译时安全性     |
| 本地缓存 | SQLite | Room        | ✅ Room       | 减少样板代码、LiveData集成 |

------

## **07. 项目成果与反思**

1. **量化成果**
   - 崩溃率降至 0.1%
   - 冷启动时间优化 40%
2. **反思与改进**
   - 初期过度设计导致开发周期延长 → 后续采用渐进式架构演进
   - 未充分覆盖边缘场景测试 → 引入自动化 Monkey 测试

------

## **08.高频面试问题预判**

1. **架构设计**
   - “为什么选 MVVM 而非 MVP？”
   - “如何保证 `ViewModel` 不持有 View 引用？”
2. **性能优化**
   - “你做过哪些内存优化？如何分析内存泄漏？”
3. **协程原理**
   - “`StateFlow` 和 `LiveData` 的区别？如何避免重复订阅？”
4. **项目难点**
   - “遇到最复杂的技术问题是什么？如何解决的？”

------

## 09.表达技巧：

1. **用 STAR 法则描述难点**：Situation → Task → Action → Result
2. **技术名词精准**：避免说“用了 RxJava”，改为“使用 `RxJava` 的 `Observable` 处理异步流，配合 `debounce` 防止重复请求”
3. **可视化辅助**：
   - 画架构分层图（展示 Clean Architecture）
   - 展示关键代码片段（如 `ViewModel` 状态管理）
4. **关联 Android 系统特性**：
   - 强调 `Lifecycle` 组件如何避免内存泄漏
   - 解释 `WorkManager` 如何适配后台限制

> 💡 **终极口诀**：
> **讲清背景 → 展示架构 → 深入细节 → 量化结果 → 反思成长**

掌握此框架，你不仅能清晰传递项目价值，还能在面试中展现技术深度与系统性思维！



## 10. **关键业务指标**：

- 这个怎么来的？

- **用户体验指标**：
  - 平均购物时长 ≤ 30秒
  - 支付成功率 ≥ 99.5%
- **系统稳定性指标**：
  - POS机崩溃率 ≤ 0.1%（金融级可靠性）
  - 从扫码到支付完成延迟 ≤ 1.5秒
- **商业价值指标**：
  - 商户人力成本下降 60%+
  - 通过热力图分析提升货架转化率 20%
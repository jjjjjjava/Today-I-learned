[toc]

## 前言

> 学习要符合如下的标准化链条：了解概念->探究原理->深入思考->总结提炼->底层实现->延伸应用"

## 01.学习概述

- **学习主题**：内存泄漏
- **知识类型**：
  - [ ] **知识类型**：
    - [ ] ✅Android/ 
      - [ ] ✅01.基础组件
      - [ ] ✅02.IPC机制
      - [ ] ✅03.消息机制
      - [ ] ✅04.View原理
      - [ ] ✅05.事件分发机制
      - [ ] ✅06.Window
      - [ ] ✅07.复杂控件
      - [x] ✅08.性能优化
      - [ ] ✅09.流行框架
      - [ ] ✅10.数据处理
      - [ ] ✅11.动画
      - [ ] ✅12.Groovy
    - [ ] ✅音视频开发/
      - [ ] ✅01.基础知识
      - [ ] ✅02.OpenGL渲染视频
      - [ ] ✅03.FFmpeg音视频解码
    - [ ] ✅ Java/
      - [ ] ✅01.基础知识
      - [ ] ✅02.Java设计思想
      - [ ] ✅03.集合框架
      - [ ] ✅04.异常处理
      - [ ] ✅05.多线程与并发编程
      - [ ] ✅06.JVM
    - [ ] ✅ Kotlin/
      - [ ] ✅01.基础语法
      - [ ] ✅02.高阶扩展
      - [ ] ✅03.协程和流
    - [ ] ✅ 故障分析与处理/
      - [ ] ✅01.基础知识
    - [ ] ✅ 自我管理/
      - [ ] ✅01.内观
    - [ ] ✅ 业务逻辑/
      - [ ] ✅01.启动逻辑
      - [ ] ✅02.云值守
      - [ ] ✅03.智控平台
- **学习来源**：feat_智控平台的过程中发现的可能存在的性能问题
- **重要程度**：⭐⭐⭐⭐⭐
- **学习日期**：2025.
- **记录人**：@panruiqi

### 1.1 学习目标

- 了解概念->探究原理->深入思考->总结提炼->底层实现->延伸应用"

### 1.2 前置知识

- [ ] 

## 02.核心概念

### 2.1 是什么？

想理解内存泄漏，需要先理解：

- GC机制，当你的对象经过可达性分析，发现无法抵达后，他会被标为垃圾。这是实际的垃圾。
- 但是还有一种：程序员视角的“垃圾”，有些对象，虽然在代码逻辑上已经“用不到了”，但由于某些地方还持有它的引用（比如Handler、单例、静态变量、全局集合等），导致GC认为它“可达”，不会回收
- 内存泄漏：这些“对我们来说已经没用，但GC还认为有用”的对象，长时间占用内存，这就是内存泄漏


### 2.2 解决什么问题？

内存泄漏的危害主要体现在以下几个方面：

- 内存占用持续升高，最终导致OOM（Out Of Memory）
  - 泄漏的对象无法被回收，随着应用运行时间增长，内存占用会不断增加。
  - 当内存耗尽时，系统会抛出OOM异常，导致应用崩溃。

-  应用卡顿、性能下降
  - 泄漏对象越多，GC需要扫描和管理的对象越多，GC频率和耗时都会增加。
  - 频繁的GC会导致应用卡顿、掉帧，影响用户体验。

-  资源无法释放
  - 泄漏的对象如果持有系统资源（如文件句柄、数据库连接、Bitmap、Context等），这些资源也无法被释放，可能导致文件打开失败、数据库锁死、图片加载失败等问题。

- Activity/Fragment泄漏导致UI异常
  - 如果Activity/Fragment泄漏，可能导致UI无法及时销毁，出现“幽灵界面”、点击无响应、甚至敏感信息泄露等问题。

-  电量消耗增加
  - 泄漏的对象可能持续执行任务（如定时器、线程），导致CPU、网络、传感器等资源被无谓消耗，加速电池消耗。

-  安全隐患
  - 泄漏的对象如果包含敏感数据（如用户信息、Token等），长时间驻留内存，增加被恶意代码窃取的风险

### 2.3 基本特性



## 03.原理机制

### 3.1 进一步思考

存泄漏为什么危害这么大啊？比如：handler持有activity的引用，然后activity被销毁，产生内存泄漏。但是我想说的是：handler迟早会被looper消费掉的，消费完，activity的引用不就没了吗，那不还是会被GC吗？所以，不是没影响吗？

- ① 消息不一定很快被消费

  - 如果你用handler.postDelayed(Runnable, 10 * 60 * 1000)（10分钟后执行），这10分钟内Activity都无法被回收。

  - 如果消息队列里有大量消息，消费速度慢，泄漏时间就长。

- ②  泄漏时间不可控

  - 只要有泄漏，哪怕只有几分钟，内存就会被白白占用，积少成多，最终OOM。

- ④ 资源链式泄漏

  - Activity泄漏，相关的View、Context、资源、线程等都无法释放，可能导致更多连锁泄漏。

### 3.2 进一步思考

有哪些经典的内存泄漏的例子？

- Handler导致的内存泄漏

  - ```
    class MyActivity : AppCompatActivity() {
        private val handler = object : Handler(Looper.getMainLooper()) {
            override fun handleMessage(msg: Message) {
                // 这里可以访问Activity的成员变量
            }
        }
    }
    ```

### 3.3 进一步思考

怎么理解：匿名内部类会隐式持有外部类（Activity）的引用。

- 

### 3.4 进一步思考

msgQueue在堆上，由主线程持有，我们子线程怎么访问到他，并把msg放进去的？

- Looper.getMainLooper()返回主线程的Looper对象，进而拿到主线程的MessageQueue。

### 3.5 进一步思考

## 04.底层原理



## 05.深度思考

### 5.1 关键问题探究



### 5.2 设计对比



## 06.实践验证

### 6.1 行为验证代码



### 6.2 性能测试





## 07.应用场景

### 7.1 最佳实践



### 7.2 使用禁忌





## 08.总结提炼

### 8.1 核心收获



### 8.2 知识图谱



### 8.3 延伸思考





## 09.参考资料

1. []()
2. []()
3. []()

## 其他介绍

### 01.关于我的博客

- csdn：http://my.csdn.net/qq_35829566

- 掘金：https://juejin.im/user/499639464759898

- github：https://github.com/jjjjjjava

- 邮箱：[934137388@qq.com]


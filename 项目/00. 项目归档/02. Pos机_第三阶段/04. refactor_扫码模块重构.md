[toc]

## 00.é‡æ„æ¦‚è¿°

- **é‡æ„ID**ï¼š`refactor-20250701-001`  
- **é‡æ„åç§°**ï¼šå¼¹çª—ç®¡ç†ç³»ç»Ÿ  ï¼ˆè€ƒè™‘åˆ°åªæœ‰mainä¸­æœ‰é¢‘ç¹çš„å¼¹çª—ï¼Œå› æ­¤æš‚æ—¶æ— éœ€å…¨å±€å”¯ä¸€å•ä¾‹ï¼Œå»å¤„ç†mainå’Œpaymentä¸­çš„å¼¹çª—ã€‚ï¼‰
- **ç›®æ ‡ç‰ˆæœ¬**ï¼šv0.3.0  
- **é‡æ„ç±»å‹**ï¼šâœ… æ¶æ„çº§é‡æ„ -
  - [x] ä¸€æ­¥åˆ°ä½æ¨¡å¼  
  - [ ] å¾ªåºæ¸è¿›é€æ­¥æ›¿ä»£æ¨¡å¼
- **é‡æ„è´Ÿè´£äºº**ï¼š@panruiqi  
- **å®Œæˆæ—¶é—´**ï¼š2025å¹´07æœˆ02æ—¥  
- **æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  

---

## 01.é‡æ„ç›®æ ‡

### 1.1 åŸæœ‰é—®é¢˜

- è€¦åˆåº¦é«˜
  - å„ç»„ä»¶å¼ºä¾èµ–äºBaseScannerActivity å’Œ BaseScannnerViewModel
  - ![image-20250701094039588](../../_pic_/image-20250701094039588.png)
  - ![image-20250701094049615](../../_pic_/image-20250701094049615.png)
- é€šè¿‡ç»§æ‰¿å®ç°
  - å„UIç»§æ‰¿è‡ªä¸Šè¿°ä¸¤ä¸ªåŸºç±»ï¼Œå®ç°ä»–ä»¬çš„å…·ä½“çš„å¤„ç†é€»è¾‘ã€‚
  - ![image-20250701094155258](../../_pic_/image-20250701094155258.png)
- **æ‰©å±•å›°éš¾**ï¼šæ–°å¢æ— æ„Ÿæ”¯ä»˜æ–¹æ¡ˆæ—¶ï¼Œè´­ç‰©è½¦é¡µå¤„ç†ä»˜æ¬¾ç æ—¶è¦ä¿®æ”¹åŸæœ‰ä»£ç ï¼Œæ²¡ä¿ç•™æ­£ç¡®çš„é¢å¤–çš„æ¥å£

### 1.2 é‡æ„ç›®æ ‡

- **ç»Ÿä¸€ç®¡ç†**ï¼šå»ºç«‹ç‹¬ç«‹å¼¹çª—ç³»ç»Ÿ
- **åŠ¨æ€åˆ›å»º**ï¼šæŒ‰éœ€åˆ›å»ºViewï¼ŒèŠ‚çœå†…å­˜
- **æ™ºèƒ½ä¼˜å…ˆçº§**ï¼šè‡ªåŠ¨å¤„ç†å¼¹çª—æŠ¢å 
- **çŠ¶æ€éš”ç¦»**ï¼šActivityé—´çŠ¶æ€ç‹¬ç«‹
- **æ•°æ®é©±åŠ¨**ï¼šåŸºäºé…ç½®åˆ›å»ºå¼¹çª—
- **é›¶XMLä¿®æ”¹**ï¼šæ–°å¢å¼¹çª—ä¸ä¿®æ”¹å¸ƒå±€

---

## 02.æ–°æ¶æ„è®¾è®¡

### 2.1 æ ¸å¿ƒç»„ä»¶

![image-20250701100420827](../../_pic_/image-20250701100420827.png)

### 2.2 æ¶æ„å®ç°

#### 1.core/BarcodeClassifier

- ç®€å•çš„æ¡ç åˆ†ç±»å™¨ï¼Œæ ¹æ®æ­£åˆ™è¡¨è¾¾å¼å»åŒ¹é…

- ```
  **
   * æ¡ç åˆ†ç±»å™¨
   * 
   * èŒè´£ï¼š
   * - å°†è¾“å…¥çš„æ¡ç åˆ†ç±»ä¸ºä¸åŒç±»å‹
   * - çº¯å‡½æ•°è®¾è®¡ï¼Œæ— çŠ¶æ€ï¼Œæ— å‰¯ä½œç”¨
   * - é«˜æ€§èƒ½ï¼Œæ”¯æŒé«˜é¢‘è°ƒç”¨
   */
  object BarcodeClassifier {
      
      // å¾®ä¿¡ä»˜æ¬¾ç è§„åˆ™ï¼šä»¥1å¼€å¤´ï¼Œç¬¬äºŒä½0-5ï¼Œæ€»é•¿åº¦18ä½
      private val WECHAT_PAYMENT_CODE_REGEX = Regex("^1[0-5]\\d{16}$")
      
      // æ”¯ä»˜å®ä»˜æ¬¾ç è§„åˆ™ï¼š25-29å¼€å¤´16-17ä½ï¼Œæˆ–30å¼€å¤´15-17ä½
      private val ALIPAY_PAYMENT_CODE_REGEX = Regex("^2[5-9]\\d{15,16}$|^30\\d{14,16}$")
      
      /**
       * åˆ†ç±»æ¡ç 
       * 
       * @param barcode åŸå§‹æ¡ç 
       * @return åˆ†ç±»ç»“æœ
       */
      fun classify(barcode: String): ScanResult {
          // é¢„å¤„ç†ï¼šå»é™¤ç©ºç™½å­—ç¬¦
          val cleanBarcode = barcode.trim()
          
          if (cleanBarcode.isEmpty()) {
              LogManager.d("æ¡ç ä¸ºç©ºï¼Œè¿”å›Unknown")
              return ScanResult.Unknown(cleanBarcode)
          }
          
          LogManager.d("åˆ†ç±»æ¡ç : $cleanBarcode")
          
          return when {
              isWeChatPaymentCode(cleanBarcode) -> {
                  LogManager.d("è¯†åˆ«ä¸ºå¾®ä¿¡ä»˜æ¬¾ç ")
                  ScanResult.PaymentCode(cleanBarcode, PaymentType.WECHAT)
              }
              isAlipayPaymentCode(cleanBarcode) -> {
                  LogManager.d("è¯†åˆ«ä¸ºæ”¯ä»˜å®ä»˜æ¬¾ç ")
                  ScanResult.PaymentCode(cleanBarcode, PaymentType.ALIPAY)
              }
              isProductCode(cleanBarcode) -> {
                  LogManager.d("è¯†åˆ«ä¸ºå•†å“ç ")
                  ScanResult.ProductCandidate(cleanBarcode)
              }
              else -> {
                  LogManager.d("æ— æ³•è¯†åˆ«çš„æ¡ç ç±»å‹")
                  ScanResult.Unknown(cleanBarcode)
              }
          }
      }
      
      /**
       * æ£€æµ‹æ˜¯å¦ä¸ºå¾®ä¿¡ä»˜æ¬¾ç 
       */
      private fun isWeChatPaymentCode(code: String): Boolean {
          return code.matches(WECHAT_PAYMENT_CODE_REGEX)
      }
      
      /**
       * æ£€æµ‹æ˜¯å¦ä¸ºæ”¯ä»˜å®ä»˜æ¬¾ç 
       */
      private fun isAlipayPaymentCode(code: String): Boolean {
          return code.matches(ALIPAY_PAYMENT_CODE_REGEX)
      }
      
      /**
       * æ£€æµ‹æ˜¯å¦ä¸ºå•†å“ç 
       * è§„åˆ™ï¼š8-14ä½æ•°å­—
       */
      private fun isProductCode(code: String): Boolean {
          return code.length in 8..14 && code.all { it.isDigit() }
      }
      
      /**
       * æ£€æµ‹æ˜¯å¦ä¸ºä»»æ„ä»˜æ¬¾ç 
       */
      fun isPaymentCode(code: String): Boolean {
          return isWeChatPaymentCode(code) || isAlipayPaymentCode(code)
      }
      
      /**
       * è·å–ä»˜æ¬¾ç ç±»å‹
       */
      fun getPaymentType(code: String): PaymentType? {
          return when {
              isWeChatPaymentCode(code) -> PaymentType.WECHAT
              isAlipayPaymentCode(code) -> PaymentType.ALIPAY
              else -> null
          }
      }
  } 
  ```

- æ­£åˆ™è¡¨è¾¾å¼

  - è¿™æ˜¯ä¸€ä¸ªç”¨äºåŒ¹é…â€œå¾®ä¿¡ä»˜æ¬¾ç â€çš„æ­£åˆ™è¡¨è¾¾å¼ï¼ˆRegexï¼‰ã€‚

  - ```
    // å¾®ä¿¡ä»˜æ¬¾ç è§„åˆ™ï¼šä»¥1å¼€å¤´ï¼Œç¬¬äºŒä½0-5ï¼Œæ€»é•¿åº¦18ä½
    private val WECHAT_PAYMENT_CODE_REGEX = Regex("^1[0-5]\\d{16}$")
    ```

  - è§„åˆ™è¯´æ˜ï¼š

  - ä»¥æ•°å­—1å¼€å¤´ï¼ˆ^1ï¼‰

  - ç¬¬äºŒä½æ˜¯0åˆ°5ä¹‹é—´çš„æ•°å­—ï¼ˆ[0-5]ï¼‰

  - åé¢è·Ÿ16ä½ä»»æ„æ•°å­—ï¼ˆ\d{16}ï¼‰

  - æ€»é•¿åº¦æ˜¯18ä½ï¼ˆå› ä¸º1 + 1 + 16 = 18ï¼‰

  - ^ è¡¨ç¤ºå­—ç¬¦ä¸²å¼€å¤´ï¼Œ$ è¡¨ç¤ºå­—ç¬¦ä¸²ç»“å°¾ï¼Œç¡®ä¿æ•´ä¸ªå­—ç¬¦ä¸²å®Œå…¨ç¬¦åˆè¿™ä¸ªæ ¼å¼

- trim

  - trim() æ˜¯ Kotlinï¼ˆå’Œ Javaï¼‰å­—ç¬¦ä¸²çš„ä¸€ä¸ªæ–¹æ³•ï¼Œç”¨äºè¿”å›å»æ‰é¦–å°¾ç©ºç™½çš„æ–°å­—ç¬¦ä¸²ã€‚

  - å‡è®¾ barcode = " 1234567890 "

  - æ‰§è¡Œ barcode.trim() åï¼ŒcleanBarcode çš„å€¼å°±æ˜¯ "1234567890"ï¼ˆå‰åçš„ç©ºæ ¼è¢«å»æ‰äº†ï¼‰ã€‚

  - ```
    // é¢„å¤„ç†ï¼šå»é™¤ç©ºç™½å­—ç¬¦
    val cleanBarcode = barcode.trim()
    ```

#### 2.core/scanResult

- æ‰«ç ç»“æœæ¨¡å‹ï¼Œæ¡ç åˆ†ç±»å™¨ä¸­å¯¹åŸå§‹æ¡ç è¿›è¡Œæ­£åˆ™è¡¨è¾¾å¼çš„åˆ¤æ–­ï¼Œå¹¶ç”Ÿæˆå¯¹åº”çš„æ‰«ç ç»“æœæ¨¡å‹ã€‚

- ```
  /**
   * @author panruiqi
   * @date 2025-06-30
   * @description æ‰«ç ç»“æœæ¨¡å‹
   * @copyright Copyright (c) 2025 ovopark
   * @contact panruiqi@ovopark.com
   */
  package com.ovopark.cloudpos.features.scanner.core
  
  /**
   * æ‰«ç ç»“æœåŸºç±»
   */
  sealed class ScanResult {
      abstract val barcode: String
      
      /**
       * å•†å“å€™é€‰ç 
       */
      data class ProductCandidate(override val barcode: String) : ScanResult()
      
      /**
       * ä»˜æ¬¾ç 
       */
      data class PaymentCode(
          override val barcode: String, 
          val type: PaymentType
      ) : ScanResult()
      
      /**
       * å¿«é€Ÿæ”¯ä»˜è§¦å‘ï¼ˆé¢„ç•™æ¥å£ï¼‰
       */
      data class QuickPaymentTrigger(
          override val barcode: String,
          val paymentType: PaymentType
      ) : ScanResult()
      
      /**
       * æœªçŸ¥æ¡ç 
       */
      data class Unknown(override val barcode: String) : ScanResult()
  }
  
  /**
   * ä»˜æ¬¾ç±»å‹
   */
  enum class PaymentType {
      WECHAT,     // å¾®ä¿¡æ”¯ä»˜
      ALIPAY      // æ”¯ä»˜å®
  }
  
  /**
   * æ‰«ç é”™è¯¯ç±»å‹
   */
  enum class ScanErrorType {
      PRODUCT_NOT_FOUND,      // å•†å“æœªæ‰¾åˆ°
      INVALID_PAYMENT_CODE,   // æ— æ•ˆä»˜æ¬¾ç 
      NETWORK_ERROR,          // ç½‘ç»œé”™è¯¯
      UNKNOWN_ERROR           // æœªçŸ¥é”™è¯¯
  } 
  ```

#### 3. core/ScanFlowProvider

- æ‰«ç è¾“å…¥æµæä¾›è€…ï¼Œç»Ÿä¸€ç®¡ç†æ‰€æœ‰çš„è¾“å…¥æº

- ç›®å‰å†…éƒ¨æœ‰ä¸¤ä¸ªæ•°æ®æµ

  - barcodeFlow æ˜¯ä¸€ä¸ª Flow<String>ï¼Œå®ƒæ˜¯æ‰€æœ‰æ‰«ç è¾“å…¥çš„â€œæ€»å…¥å£â€ã€‚

  - ç›®å‰æœ‰ä¸¤ä¸ªè¾“å…¥æºï¼š

    - keyboardScanFlowï¼šé”®ç›˜æ‰«ç æªè¾“å…¥ï¼ˆé€šè¿‡å…¨å±€ KeyEvent ç›‘å¬ï¼‰
    - _manualScanFlowï¼šæ‰‹åŠ¨è¾“å…¥ï¼ˆé€šè¿‡ emitBarcode æ–¹æ³•æ‰‹åŠ¨æ³¨å…¥ï¼‰

  - è¿™ä¸¤ä¸ªè¾“å…¥æºé€šè¿‡ merge() åˆå¹¶æˆä¸€ä¸ª barcodeFlowï¼Œå¤–éƒ¨åªéœ€è¦è®¢é˜… barcodeFlow å°±èƒ½æ‹¿åˆ°æ‰€æœ‰æ‰«ç æ•°æ®

  - ```
    /**
     * æ‰«ç è¾“å…¥æµæä¾›è€…
     * 
     * èŒè´£ï¼š
     * - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰æ‰«ç è¾“å…¥æº
     * - æä¾›å»é‡ã€é˜²æŠ–ç­‰æ•°æ®å¤„ç†
     * - æ”¯æŒé”®ç›˜æ‰«ç æªã€ç›¸æœºæ‰«ç ç­‰å¤šç§è¾“å…¥
     */
    class ScanFlowProvider(private val context: Context) {
        //æ‰‹åŠ¨æ‰«ç è¾“å…¥æ•°æ®æµ
        private val _manualScanFlow = MutableSharedFlow<String>()
        
        /**
         * é”®ç›˜æ‰«ç æªè¾“å…¥æµ
         */
        private val keyboardScanFlow: Flow<String> = callbackFlow {
           .......................
        }
        
        /**
         * ä¸»è¦çš„æ‰«ç æ•°æ®æµ
         */
        val barcodeFlow: Flow<String> = merge(
            keyboardScanFlow,           // é”®ç›˜æ‰«ç æªè¾“å…¥
            _manualScanFlow.asSharedFlow()  // æ‰‹åŠ¨æ‰«ç è¾“å…¥
        )
        .debounce(50)       // é˜²æŠ–50msï¼Œæé«˜å“åº”é€Ÿåº¦
        .filter { it.isNotBlank() }    // è¿‡æ»¤ç©ºå­—ç¬¦ä¸²
        .onEach { barcode ->
            LogManager.i("æ‰«ç è¾“å…¥æ£€æµ‹åˆ°: $barcode")
        }
       
    }
    ```

- æˆ‘ä»¬æ¥ç®€å•çœ‹ä¸€ä¸‹é”®ç›˜æ‰«ç æªè¾“å…¥æµ

  - æŠŠâ€œæ‰«ç æªé€šè¿‡æ¨¡æ‹Ÿé”®ç›˜è¾“å…¥çš„æ–¹å¼â€äº§ç”Ÿçš„æ‰«ç æ•°æ®ï¼Œè½¬åŒ–ä¸ºä¸€ä¸ª Kotlin Flowï¼ˆå¼‚æ­¥æ•°æ®æµï¼‰ï¼Œè®©ä½ å¯ä»¥åƒç›‘å¬äº‹ä»¶ä¸€æ ·æ”¶é›†æ‰«ç ç»“æœ

  - å®ç°åŸç†ï¼š

    - å…³é”®ç‚¹ï¼š

      - callbackFlowï¼šç”¨äºæŠŠå›è°ƒå¼çš„äº‹ä»¶ï¼ˆå¦‚é”®ç›˜äº‹ä»¶ï¼‰è½¬æˆ Flowã€‚

      - KeyboardScanInputHandlerï¼šå…¨å±€å•ä¾‹ï¼Œè´Ÿè´£åˆ†å‘ KeyEvent ç»™æ‰€æœ‰æ³¨å†Œçš„å¤„ç†å™¨ã€‚

      - inputHandlerï¼šæœ¬åœ°å¯¹è±¡ï¼Œè´Ÿè´£å¤„ç† KeyEventï¼ŒæŠŠæ‰«ç æ•°æ®æ‹¼æ¥æˆå­—ç¬¦ä¸²ï¼Œé‡åˆ°å›è½¦é”®æ—¶å‘é€å‡ºå»

  - ```
    /**
         * é”®ç›˜æ‰«ç æªè¾“å…¥æµ
         */
        private val keyboardScanFlow: Flow<String> = callbackFlow {
            val scanBuffer = StringBuilder()
            var lastKeyTime = 0L
            
            val inputHandler = object {
                fun handleKeyEvent(event: KeyEvent): Boolean {
                    if (event.action != KeyEvent.ACTION_DOWN) return false
                    
                    val currentTime = System.currentTimeMillis()
                    val keyCode = event.keyCode
                    
                    // å¦‚æœé—´éš”æ—¶é—´è¿‡é•¿ï¼Œæ¸…ç©ºç¼“å†²åŒºï¼ˆè®¤ä¸ºæ˜¯æ–°çš„æ‰«ç å¼€å§‹ï¼‰
                    if (currentTime - lastKeyTime > 100) {
                        scanBuffer.clear()
                    }
                    lastKeyTime = currentTime
                    
                    when (keyCode) {
                        KeyEvent.KEYCODE_ENTER -> {
                            // å›è½¦é”®è¡¨ç¤ºæ‰«ç ç»“æŸ
                            if (scanBuffer.isNotEmpty()) {
                                val barcode = scanBuffer.toString()
                                scanBuffer.clear()
                                LogManager.d("é”®ç›˜æ‰«ç å®Œæˆ: $barcode")
                                val result = trySend(barcode)
                                LogManager.d("æ‰«ç æ•°æ®å‘é€ç»“æœ: ${result.isSuccess}, æ•°æ®: $barcode")
                            }
                            return true
                        }
                        in KeyEvent.KEYCODE_0..KeyEvent.KEYCODE_9 -> {
                            // æ•°å­—é”®
                            val char = (keyCode - KeyEvent.KEYCODE_0 + '0'.code).toChar()
                            scanBuffer.append(char)
                            return true
                        }
                        KeyEvent.KEYCODE_PERIOD -> {
                            // å°æ•°ç‚¹
                            scanBuffer.append('.')
                            return true
                        }
                        KeyEvent.KEYCODE_MINUS -> {
                            // å‡å·
                            scanBuffer.append('-')
                            return true
                        }
                        // å…¶ä»–å­—ç¬¦é”®å¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ 
                    }
                    
                    return false
                }
            }
            
            // æ³¨å†Œåˆ°å…¨å±€é”®ç›˜ç›‘å¬å™¨
            KeyboardScanInputHandler.register(inputHandler::handleKeyEvent)
            
            awaitClose {
                KeyboardScanInputHandler.unregister(inputHandler::handleKeyEvent)
                LogManager.d("é”®ç›˜æ‰«ç ç›‘å¬å™¨å·²æ¸…ç†")
            }
        }
        
        
    /**
     * é”®ç›˜æ‰«ç è¾“å…¥å¤„ç†å™¨
     * 
     * å…¨å±€å•ä¾‹ï¼Œç®¡ç†é”®ç›˜äº‹ä»¶ç›‘å¬
     */
    object KeyboardScanInputHandler {
        private val handlers = mutableSetOf<(KeyEvent) -> Boolean>()
        
        fun register(handler: (KeyEvent) -> Boolean) {
            handlers.add(handler)
            LogManager.d("æ³¨å†Œé”®ç›˜æ‰«ç å¤„ç†å™¨ï¼Œå½“å‰å¤„ç†å™¨æ•°é‡: ${handlers.size}")
        }
        
        fun unregister(handler: (KeyEvent) -> Boolean) {
            handlers.remove(handler)
            LogManager.d("æ³¨é”€é”®ç›˜æ‰«ç å¤„ç†å™¨ï¼Œå½“å‰å¤„ç†å™¨æ•°é‡: ${handlers.size}")
        }
        
        /**
         * å¤„ç†é”®ç›˜äº‹ä»¶
         * 
         * @param event é”®ç›˜äº‹ä»¶
         * @return æ˜¯å¦æ¶ˆè´¹äº†äº‹ä»¶
         */
        fun handleKeyEvent(event: KeyEvent): Boolean {
            var consumed = false
            handlers.forEach { handler ->
                if (handler(event)) {
                    consumed = true
                }
            }
            return consumed
        }
        
        /**
         * é‡ç½®æ‰€æœ‰å¤„ç†å™¨
         */
        fun reset() {
            handlers.clear()
            LogManager.d("é‡ç½®æ‰€æœ‰é”®ç›˜æ‰«ç å¤„ç†å™¨")
        }
    } 
    ```

#### 4.dsl/ScanDSl

- æ‰«ç DSLæ„å»ºå™¨ï¼Œç”¨äºæ„å»ºæ‰«ç å¤„ç†èƒ½åŠ›ï¼ˆå¤„ç†å•†å“ç ï¼Œå¾®ä¿¡ä»˜æ¬¾ç ï¼Œæ”¯ä»˜å®ä»˜æ¬¾ç ï¼‰

- å…³é”®ç‚¹ï¼š

  - é€šè¿‡å£°æ˜å¼çš„ï¼Œä¾‹å¦‚ï¼šproductå»é…ç½®å•†å“æ‰«ç å¤„ç†çš„èƒ½åŠ›ï¼Œä¼ é€’çš„æ˜¯ `action: suspend (barcode: String, product: Product) -> Unit` è¿™ä¸ªå¸¦ä¸¤ä¸ªå‚æ•°ã€æ— è¿”å›å€¼çš„å‡½æ•°ç±»å‹ã€‚å…·ä½“å¯ä»¥çœ‹study_lambdaè¡¨è¾¾å¼ã€‚

  - ç„¶åæˆ‘ä»¬ç”¨ProductScanHandlerå»åŒ…è£¹è¿™ä¸ªå‡½æ•°ç±»å‹

    - ProductScanHandleræ˜¯ScanHandleræ–‡ä»¶ä¸­ä¸€ä¸ªç±»ï¼Œå…¶æ„é€ æ–¹æ³•æ¥å—actionå‚æ•°ï¼Œå¹¶åœ¨handleæ–¹æ³•ä¸­è°ƒç”¨è¿™ä¸ªå‡½æ•°ç±»å‹

    - ```
      /**
       * æ‰«ç å¤„ç†å™¨åŸºç¡€æ¥å£
       */
      interface ScanHandler
      
      /**
       * å•†å“æ‰«ç å¤„ç†å™¨
       */
      class ProductScanHandler(
          private val action: suspend (barcode: String, product: Product) -> Unit
      ) : ScanHandler {
          
          suspend fun handle(barcode: String, product: Product) {
              action(barcode, product)
          }
      }
      ```

    - ä¸ºä»€ä¹ˆè¦è¿™æ ·ï¼Ÿå› ä¸ºä¸åŒçš„å¤„ç†èƒ½åŠ›ä¸ä¸€å®šå¯ä»¥é€šè¿‡ä¸€ä¸ªactionå¤„ç†å®Œæˆï¼Œæ¯”å¦‚ä»˜æ¬¾ç å¤„ç†å™¨ï¼Œéœ€è¦å»åŒ¹é…å¯¹åº”çš„æ‰«ç åœºæ™¯ï¼Œmainä¸­æ˜¯å¿«é€Ÿä»˜æ¬¾ï¼Œpaymentä¸­æ˜¯æ­£å¸¸ä»˜æ¬¾

    - ```
      /**
       * ä»˜æ¬¾ç æ‰«ç å¤„ç†å™¨
       */
      class PaymentCodeScanHandler(
          private val scene: String,
          private val action: suspend (barcode: String, type: PaymentType) -> Unit
      ) : ScanHandler {
          
          suspend fun handle(barcode: String, type: PaymentType) {
              action(barcode, type)
          }
          
          fun matchesScene(currentScene: String): Boolean {
              return scene == "*" || scene == currentScene
          }
      }
      ```

  - ```
    /**
     * æ‰«ç DSLæ„å»ºå™¨
     * 
     * æä¾›å£°æ˜å¼çš„æ‰«ç å¤„ç†é…ç½®
     */
    class ScanDslBuilder {
        private val handlers = mutableMapOf<String, ScanHandler>()
        
        /**
         * é…ç½®å•†å“æ‰«ç å¤„ç†
         * 
         * @param action å¤„ç†å•†å“æ‰«ç çš„åŠ¨ä½œ
         */
        fun product(action: suspend (barcode: String, product: Product) -> Unit) {
            handlers["product"] = ProductScanHandler(action)
        }
        
        /**
         * é…ç½®ä»˜æ¬¾ç æ‰«ç å¤„ç†
         * 
         * @param inScene é™å®šåœ¨ç‰¹å®šåœºæ™¯ï¼Œ"*"è¡¨ç¤ºæ‰€æœ‰åœºæ™¯
         * @param action å¤„ç†ä»˜æ¬¾ç æ‰«ç çš„åŠ¨ä½œ
         */
        fun paymentCode(
            inScene: String = "*", 
            action: suspend (barcode: String, type: PaymentType) -> Unit
        ) {
            val key = "payment_$inScene"
            handlers[key] = PaymentCodeScanHandler(inScene, action)
        }
        
        /**
         * é…ç½®å¿«é€Ÿæ”¯ä»˜å¤„ç†ï¼ˆé¢„ç•™æ¥å£ï¼‰
         * 
         * @param action å¤„ç†å¿«é€Ÿæ”¯ä»˜çš„åŠ¨ä½œ
         */
        fun quickPayment(action: suspend (barcode: String, type: PaymentType) -> Unit) {
            handlers["quick_payment"] = QuickPaymentScanHandler(action)
        }
        
        /**
         * é…ç½®é”™è¯¯å¤„ç†
         * 
         * @param action å¤„ç†æ‰«ç é”™è¯¯çš„åŠ¨ä½œ
         */
        fun error(action: (errorType: ScanErrorType, message: String) -> Unit) {
            handlers["error"] = ErrorScanHandler(action)
        }
        
        /**
         * é…ç½®æœªçŸ¥æ¡ç å¤„ç†
         * 
         * @param action å¤„ç†æœªçŸ¥æ¡ç çš„åŠ¨ä½œ
         */
        fun unknown(action: (barcode: String) -> Unit) {
            handlers["unknown"] = UnknownScanHandler(action)
        }
        
        /**
         * æ„å»ºå¤„ç†å™¨æ˜ å°„
         */
        internal fun build(): Map<String, ScanHandler> = handlers.toMap()
    } 
    ```

  - å¥½ï¼Œæˆ‘ä»¬ä¸Šé¢é€šè¿‡  private val handlers = mutableMapOf<String, ScanHandler>() å®¹çº³äº†ä¸åŒçš„å¤„ç†å™¨ï¼Œæ¥ä¸‹æ¥å¯ä»¥é€šè¿‡ buildæ–¹æ³•

    - å…¶è¿”å›å€¼ç±»å‹æ˜¯ Map<String, ScanHandler>ã€‚
    - ä½œç”¨æ˜¯æŠŠå†…éƒ¨çš„ handlers é›†åˆè½¬æ¢ä¸ºä¸å¯å˜çš„ Map å¹¶è¿”å›ã€‚
    - handlers æ˜¯ä¸€ä¸ª MutableMap<String, ScanHandler> æˆ–ç±»ä¼¼çš„æ•°æ®ç»“æ„ï¼Œç”¨äºå­˜å‚¨â€œæ‰«ç å¤„ç†å™¨â€çš„æ˜ å°„å…³ç³»ã€‚

  - å…¸å‹åœºæ™¯ï¼šåœ¨ Kotlin çš„ DSL æ„å»ºå™¨æ¨¡å¼ä¸­ï¼Œå¸¸è§çš„å†™æ³•æ˜¯ï¼š

    - å…ˆç”¨å„ç§ DSL è¯­æ³•ï¼ˆå¦‚ scan { ... }ï¼‰å¾€å†…éƒ¨é›†åˆé‡Œæ·»åŠ æ•°æ®ï¼ˆå¦‚ handlerï¼‰ã€‚

    - æœ€åé€šè¿‡ build() æ–¹æ³•ä¸€æ¬¡æ€§ç”Ÿæˆæœ€ç»ˆçš„æ•°æ®ç»“æ„ï¼ˆå¦‚ Mapã€Listã€å¯¹è±¡ç­‰

#### 5.lifecycle/ScanController

- æ‰«ç æ§åˆ¶å™¨ï¼Œåè°ƒæ‰«ç æ•°æ®æµå’Œå¤„ç†å™¨ï¼Œå°†æ‰«ç æ•°æ®æµç”Ÿæˆæ‰«ç ç»“æœï¼Œå¹¶åˆ†å‘ç»™å¯¹åº”çš„å¤„ç†å™¨å¤„ç†ã€‚

- å…³é”®ç‚¹

  - å¯åŠ¨ç›‘å¬ï¼Œä»scanFlowProviderä¸­è·å–æ‰«ç æ•°æ®æµï¼Œç„¶åé€šè¿‡BarcodeClassifierè¿›è¡Œåˆ†ç±»ï¼Œå¹¶é€šè¿‡handleScanResultè¿›è¡Œå®é™…å¤„ç†ã€‚

  - ```
    private fun startScanning() {
        scanJob?.cancel() // å…ˆå–æ¶ˆä¹‹å‰çš„ç›‘å¬Jobï¼Œé¿å…é‡å¤ç›‘å¬
    
        scanJob = scanFlowProvider.barcodeFlow // è®¢é˜…æ‰«ç æ•°æ®æµ
            .onStart { LogManager.d("æ‰«ç æ•°æ®æµå¼€å§‹ç›‘å¬") } // æµå¼€å§‹æ—¶æ‰“å°æ—¥å¿—
            .onEach { barcode -> LogManager.d("æ”¶åˆ°åŸå§‹æ‰«ç æ•°æ®: $barcode") } // æ¯æ”¶åˆ°ä¸€ä¸ªæ¡ç ï¼Œæ‰“å°æ—¥å¿—
            .map { barcode -> 
                val result = BarcodeClassifier.classify(barcode) // å¯¹æ¡ç è¿›è¡Œåˆ†ç±»
                LogManager.d("æ¡ç åˆ†ç±»ç»“æœ: ${result::class.simpleName}, æ¡ç : $barcode")
                result
            }
            .onEach { result -> 
                LogManager.d("å‡†å¤‡å¤„ç†æ‰«ç ç»“æœ: ${result::class.simpleName}, æ¡ç : ${result.barcode}")
                handleScanResult(result) // å¤„ç†åˆ†ç±»åçš„æ‰«ç ç»“æœ
            }
            .catch { error -> 
                LogManager.e("æ‰«ç æµå¤„ç†å¼‚å¸¸: ${error.message}", error)
                handleError(ScanErrorType.UNKNOWN_ERROR, error.message ?: "æ‰«ç å¤„ç†å¤±è´¥") // å¼‚å¸¸å¤„ç†
            }
            .launchIn(activity.lifecycleScope) // åœ¨ç”Ÿå‘½å‘¨æœŸä½œç”¨åŸŸå†…å¯åŠ¨åç¨‹æ”¶é›†
    
        LogManager.d("æ‰«ç ç›‘å¬å·²å¯åŠ¨")
    }
    ```

    

  - ```
    
        /**
         * å¤„ç†æ‰«ç ç»“æœ
         */
        private suspend fun handleScanResult(result: ScanResult) {
            LogManager.i("å¤„ç†æ‰«ç ç»“æœ: ${result::class.simpleName}, æ¡ç : ${result.barcode}")
            
            when (result) {
                is ScanResult.ProductCandidate -> handleProductScan(result.barcode)
                is ScanResult.PaymentCode -> handlePaymentCodeScan(result.barcode, result.type)
                is ScanResult.QuickPaymentTrigger -> handleQuickPaymentScan(result.barcode, result.paymentType)
                is ScanResult.Unknown -> handleUnknownScan(result.barcode)
            }
        }
        
        /**
         * å¤„ç†å•†å“æ‰«ç 
         */
        private suspend fun handleProductScan(barcode: String) {
            val handler = handlers["product"] as? ProductScanHandler
            if (handler == null) {
                LogManager.w("æœªæ‰¾åˆ°å•†å“æ‰«ç å¤„ç†å™¨")
                return
            }
            
            try {
                LogManager.i("æŸ¥è¯¢å•†å“: $barcode")
                val result = scannerRepository.getProductByBarcode(barcode)
                when (result) {
                    is com.ovopark.cloudpos.shared.data.model.ApiResult.Success -> {
                        val product = result.data
                        handler.handle(barcode, product)
                        LogManager.i("å•†å“æ‰«ç å¤„ç†å®Œæˆ: ${product.goodsName}")
                    }
                    is com.ovopark.cloudpos.shared.data.model.ApiResult.Error -> {
                        LogManager.e("å•†å“æŸ¥è¯¢å¤±è´¥: ${result.exception.message}", result.exception)
                        handleError(ScanErrorType.PRODUCT_NOT_FOUND, "æœªæ‰¾åˆ°å•†å“")
                    }
                    is com.ovopark.cloudpos.shared.data.model.ApiResult.Loading -> {
                        // LoadingçŠ¶æ€åœ¨åŒæ­¥è°ƒç”¨ä¸­é€šå¸¸ä¸ä¼šå‡ºç°ï¼Œä½†ä¸ºäº†å®Œæ•´æ€§æ·»åŠ 
                        LogManager.d("å•†å“æŸ¥è¯¢åŠ è½½ä¸­...")
                    }
                }
            } catch (e: Exception) {
                LogManager.e("å•†å“æŸ¥è¯¢å¼‚å¸¸: ${e.message}", e)
                handleError(ScanErrorType.NETWORK_ERROR, "ç½‘ç»œé”™è¯¯")
            }
        }
        
        /**
         * å¤„ç†ä»˜æ¬¾ç æ‰«ç 
         */
        private suspend fun handlePaymentCodeScan(barcode: String, type: com.ovopark.cloudpos.features.scanner.core.PaymentType) {
            // æŸ¥æ‰¾åŒ¹é…å½“å‰åœºæ™¯çš„å¤„ç†å™¨
            val specificHandler = handlers["payment_$currentScene"] as? PaymentCodeScanHandler
            val generalHandler = handlers["payment_*"] as? PaymentCodeScanHandler
            
            val handler = when {
                specificHandler?.matchesScene(currentScene) == true -> specificHandler
                generalHandler?.matchesScene(currentScene) == true -> generalHandler
                else -> null
            }
            
            if (handler == null) {
                LogManager.w("æœªæ‰¾åˆ°ä»˜æ¬¾ç å¤„ç†å™¨ï¼Œåœºæ™¯: $currentScene")
                handleError(ScanErrorType.INVALID_PAYMENT_CODE, "å½“å‰åœºæ™¯ä¸æ”¯æŒä»˜æ¬¾ç ")
                return
            }
            
            try {
                LogManager.i("å¤„ç†ä»˜æ¬¾ç : $barcode, ç±»å‹: $type, åœºæ™¯: $currentScene")
                handler.handle(barcode, type)
                LogManager.i("ä»˜æ¬¾ç å¤„ç†å®Œæˆ")
            } catch (e: Exception) {
                LogManager.e("ä»˜æ¬¾ç å¤„ç†å¤±è´¥: ${e.message}", e)
                handleError(ScanErrorType.INVALID_PAYMENT_CODE, "ä»˜æ¬¾ç å¤„ç†å¤±è´¥")
            }
        }
        
        /**
         * å¤„ç†å¿«é€Ÿæ”¯ä»˜æ‰«ç ï¼ˆé¢„ç•™æ¥å£ï¼‰
         */
        private suspend fun handleQuickPaymentScan(barcode: String, type: com.ovopark.cloudpos.features.scanner.core.PaymentType) {
            val handler = handlers["quick_payment"] as? QuickPaymentScanHandler
            if (handler == null) {
                LogManager.w("æœªæ‰¾åˆ°å¿«é€Ÿæ”¯ä»˜å¤„ç†å™¨")
                // é™çº§åˆ°æ™®é€šä»˜æ¬¾ç å¤„ç†
                handlePaymentCodeScan(barcode, type)
                return
            }
            
            try {
                LogManager.i("å¤„ç†å¿«é€Ÿæ”¯ä»˜: $barcode, ç±»å‹: $type")
                handler.handle(barcode, type)
                LogManager.i("å¿«é€Ÿæ”¯ä»˜å¤„ç†å®Œæˆ")
            } catch (e: Exception) {
                LogManager.e("å¿«é€Ÿæ”¯ä»˜å¤„ç†å¤±è´¥: ${e.message}", e)
                handleError(ScanErrorType.INVALID_PAYMENT_CODE, "å¿«é€Ÿæ”¯ä»˜å¤±è´¥")
            }
        }
        
        /**
         * å¤„ç†æœªçŸ¥æ¡ç 
         */
        private fun handleUnknownScan(barcode: String) {
            val handler = handlers["unknown"] as? UnknownScanHandler
            if (handler != null) {
                LogManager.i("å¤„ç†æœªçŸ¥æ¡ç : $barcode")
                handler.handle(barcode)
            } else {
                LogManager.w("æœªçŸ¥æ¡ç ä¸”æ— å¤„ç†å™¨: $barcode")
                handleError(ScanErrorType.UNKNOWN_ERROR, "æ— æ³•è¯†åˆ«çš„æ¡ç : $barcode")
            }
        }
        
        /**
         * å¤„ç†é”™è¯¯
         */
        private fun handleError(type: ScanErrorType, message: String) {
            val handler = handlers["error"] as? ErrorScanHandler
            if (handler != null) {
                LogManager.d("å¤„ç†æ‰«ç é”™è¯¯: $type, $message")
                handler.handle(type, message)
            } else {
                LogManager.w("æ‰«ç é”™è¯¯ä½†æ— é”™è¯¯å¤„ç†å™¨: $type, $message")
            }
        }
    } 
    ```
    
  - Mainä¸­ä½¿ç”¨
  
    - ![image-20250701191244289](../../_pic_/image-20250701191244289.png)

## 03.æ–‡ä»¶ç»“æ„å˜åŒ–

### 3.1 æ–°å¢æ–‡ä»¶



### 3.2 ä¿®æ”¹å†…å®¹

- 


### 3.3 å¤‡ä»½æ–‡ä»¶

- 

## 04.ä½¿ç”¨æ–¹å¼å¯¹æ¯”

### 4.1 é‡æ„å‰ï¼ˆæ—§æ–¹å¼ï¼‰



### 4.2 é‡æ„åï¼ˆæ–°æ–¹å¼ï¼‰

- 


## 05.æ ¸å¿ƒä¼˜åŠ¿

- è¿™é‡Œæ˜¯xmlå¯¹æ¯”ï¼š
  - 

------

## 06.é‡æ„æ•ˆæœé‡åŒ–

### 6.1 ä»£ç é‡å‡å°‘

### 6.2 æ–°å¢æ ¸å¿ƒç»„ä»¶

- 

### 6.3 å‡€æ•ˆæœ

- 

## 07.æµ‹è¯•å»ºè®®

### 7.1 åŠŸèƒ½æµ‹è¯•

### 7.2 æ€§èƒ½æµ‹è¯•


### 7.3 è¾¹ç•Œæµ‹è¯•


### 7.4 å¿…æµ‹é¡¹ç›®



------

## 08.æ‰©å±•æŒ‡å—



## 09.æ€»ç»“

### 9.1 é‡æ„æˆæœ



### 9.2 æŠ€æœ¯ä»·å€¼

1. 

### 9.3 ä¸šåŠ¡ä»·å€¼

1. 

### 9.4 ä¸‹ä¸€æ­¥è®¡åˆ’

1. 

## ğŸ“ æ”¯æŒ

å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œè¯·è”ç³»ï¼španruiqi@ovopark.com

**é‡æ„å®Œæˆæ—¶é—´**ï¼š2025å¹´06æœˆ21æ—¥  
**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0 




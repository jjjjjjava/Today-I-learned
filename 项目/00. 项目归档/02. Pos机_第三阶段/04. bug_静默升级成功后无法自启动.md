[toc]

## 01.功能概述

- **[优先级] **
  - [ ] ⚠️ 阻断 (Blocker)：系统崩溃、核心功能完全不可用
  - [ ] 🔴 严重 (Critical)：核心功能受损，无可用替代方案
  - [ ] 🟠 高 (High)：主要功能受影响，但有临时解决方案
  - [ ] 🟡 中 (Medium)：次要功能问题，影响用户体验
  - [ ] 🟢 低 (Low)：界面问题或轻微异常，不影响功能
- **问题简要描述**
  - **Bug ID**：`BUG-20240715-001`  
  - **影响版本**：v0.4.0
  - **提交人**：@panruiqi
  - **状态**：
    - [x] ⌛ 修复中 /
    - [ ] ✅ 已解决 / 
    - [ ] ❌ 无法复现  

- **问题现象**
  - 当我的应用使用 root 权限安装更新时，系统会终止我的应用进程（这在软件包替换过程中是正常现象），但我的应用不会在安装完成后自动重启。
- **环境特征**
  - 

## 02.问题分析

### 2.1 日志分析

- ![image-20250715105107193](../../_pic_/image-20250715105107193.png)

- 系统因为PM更新应用的包，强制终止了当前应用的进程。

### 2.2 根本原因推理

- 系统因为PM更新应用的包，强制终止了当前应用的进程。

## 03.代码分析

### 3.1 关联代码路径

- ![image-20250715104939046](../../_pic_/image-20250715104939046.png)

### 3.2 可疑修改点

- 

## 04.复现步骤





## 05.解决方案尝试

### 5.1 第一次解决方案

- 分析：很简单，添加一个定时启动的任务呗
  - 
- 解决方案：
  - 
- 结果：
  - 我是傻狗，这是进程级别的终止，定时启动的任务不启用。

### 5.2 第二次解决方案

- 分析：当前应用的进程被终止，那么当前应用就是不顶用了，我们需要创建一个独立的守护进程才能重启他
- 解决方案：启动一个service，运行在指定的进程中
  - ![image-20250715105340116](../../_pic_/image-20250715105340116.png)
  - ![image-20250715105526638](../../_pic_/image-20250715105526638.png)
  - ![image-20250715105511691](../../_pic_/image-20250715105511691.png)
- 结果：
  - 未成功启动，因为它被杀死了。即使将Service设为独立进程，它仍然属于同一个应用包名，当包被替换时会一起被终止。

### 5.3 第三次解决方案

- 分析：需要启动一个单独的进程，不能这样启动一个应用包名下的

  - 

- 解决方案：sh命令启动一个与当前应用分离的进程

  - ![image-20250715105737081](../../_pic_/image-20250715105737081.png)
  - ![image-20250715105716987](../../_pic_/image-20250715105716987.png)
  - ![image-20250715105646857](../../_pic_/image-20250715105646857.png)

- 结果：

  - 守护进程好像没有正确执行，同时遇到文件路径问题：

  - ```
    Error: Unable to open file: "/storage/emulated/0/Android/data/com.ovopark.cloudpos/files/Download/apk_download/update_0.2.0.apk"
    Consider using a file under /data/local/tmp/
    ```

  - APK文件路径问题 - 尝试将APK文件复制到系统能访问的路径

  - 确保Shell脚本有正确的权限并能正常执行

### 5.4 第四次解决方案

- 分析：
  - APK文件路径问题 - 尝试将APK文件复制到系统能访问的路径
  - 确保Shell脚本有正确的权限并能正常执行

- 解决方法：增强权限，同时通过添加了copyApkToTmpDir方法，将APK文件复制到/data/local/tmp/目录，来解决APK文件路径问题
  - ![image-20250715105950940](../../_pic_/image-20250715105950940.png)
  - ![image-20250715110003241](../../_pic_/image-20250715110003241.png)
  - ![image-20250715110016006](../../_pic_/image-20250715110016006.png)
- 结果：
  - 日志中并没有显示我们的Shell守护进程是否成功启动并运行。

### 5.4 第五次解决方案

- 分析：上述的解决方案全部存在问题
  - 对于传统的启动进程，其和当前应用同一包名，会被杀死。
  - 而使用shell命令启动一个无关的进程没法很好的自动重试，同时需要权限提升，不符合Android安全模型
- 解决方案：采用WorkManager系统服务尝试进行重启
  - ![image-20250715134021452](../../_pic_/image-20250715134021452.png)
  - 这里的work为下面的
  - ![image-20250715134037171](../../_pic_/image-20250715134037171.png)
- 结果：该任务仍然被杀死
  - ![image-20250715133907828](../../_pic_/image-20250715133907828.png)



### 5.5 第五次解决方案

- 分析：上述的解决方案全部存在问题
  - 全部会被杀死，我们只能转换思路，现在启用一个新的应用来监听他
- 解决方案：我们现在添加一个额外的应用吧，Daemon，他用于监听CloudPos安装更新后来重启CloudPos
  - ![image-20250715135424254](../../_pic_/image-20250715135424254.png)
  - ![image-20250715135438387](../../_pic_/image-20250715135438387.png)
  - ![image-20250715135450071](../../_pic_/image-20250715135450071.png)
  - ![image-20250715135522702](../../_pic_/image-20250715135522702.png)
  - ![image-20250715135601720](../../_pic_/image-20250715135601720.png)
  - ![image-20250715135613938](../../_pic_/image-20250715135613938.png)
  - 在CloudPos中确认其已经运行
  - ![image-20250715135849387](../../_pic_/image-20250715135849387.png)
- 结果：启动失败，系统安全设置，不允许直接访问
  - ![image-20250715142908371](../../_pic_/image-20250715142908371.png)

### 5.6 第六次解决方案

- 分析：权限存在问题
  - ![image-20250715143417655](../../_pic_/image-20250715143417655.png)
- 解决方案：添加queries
  - ![image-20250715143413626](../../_pic_/image-20250715143413626.png)

- 结果：启动成功

## 06.进一步思考

### 6.1 有没有其他更优雅的方案

- 

### 6.2 推荐方案

```

```



## 07.根本原因和修复

### 7.1 最终定位

- 


### 7.2 修复方案



## 08.经验总结

### 8.1 技术原理

### 8.2 预防措施

### 8.3 卸载规范

### 8.4 调试技巧




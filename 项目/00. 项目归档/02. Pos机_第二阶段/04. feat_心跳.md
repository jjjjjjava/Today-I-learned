[toc]

## 01.åŠŸèƒ½æ¦‚è¿°

- **åŠŸèƒ½ID**ï¼š`FEAT-202506020-001`  
- **åŠŸèƒ½åç§°**ï¼šå¯¹æ¥DMSå¹³å°ï¼Œç»´æŒå¿ƒè·³ä¿¡æ¯
- **ç›®æ ‡ç‰ˆæœ¬**ï¼šv0.2.0
- **æäº¤äºº**ï¼š@panruiqi  
- **çŠ¶æ€**ï¼š
  - [x] âŒ› è®¾è®¡ä¸­ /
  - [ ] âŒ› å¼€å‘ä¸­ / 
  - [ ] âœ… å·²å®Œæˆ / 
  - [ ] âŒ å·²å–æ¶ˆ  
- **ä»·å€¼è¯„ä¼°**ï¼š  
  - [x] â­â­â­â­â­ æ ¸å¿ƒä¸šåŠ¡åŠŸèƒ½  
  - [ ] â­â­â­â­ ç”¨æˆ·ä½“éªŒä¼˜åŒ–  
  - [ ] â­â­â­ è¾…åŠ©åŠŸèƒ½å¢å¼º  
  - [ ] â­â­ æŠ€æœ¯å€ºåŠ¡æ¸…ç†  
- **åŠŸèƒ½æè¿°** 
  - APKç”Ÿå‘½å‘¨æœŸä¸­ä¸€ç›´æ¥å…¥DMSå¹³å°ï¼ŒæŠ¥å‘Šè‡ªèº«çš„å¿ƒè·³çŠ¶æ€ã€‚



## 02.éœ€æ±‚åˆ†æ

### 2.1 ç”¨æˆ·åœºæ™¯

- **ä¸»è¦åœºæ™¯**ï¼š  
  - ç”¨æˆ·å¯åŠ¨Posæœºï¼Œå¯åŠ¨CloudPos APKï¼Œå…¶æ¥å…¥DMSå¹³å°ï¼Œæˆ‘ä»¬ä½œä¸ºæœåŠ¡æä¾›æ–¹ï¼Œå¯ä»¥è§‚æµ‹åˆ°è¯¥è®¾å¤‡å¯åŠ¨ä¸Šçº¿ã€‚

- **è¾¹ç•Œåœºæ™¯**ï¼š  

### 2.2 åŠŸèƒ½èŒƒå›´

- âœ… åŒ…å«ï¼š
- âŒ ä¸åŒ…å«ï¼š



## 03.æŠ€æœ¯æ–¹æ¡ˆ

### 3.0 æ€è·¯ï¼š

- å·²æœ‰å†…å®¹ï¼š
  - è®¾å¤‡å…¥ç½‘æ•™ç¨‹ï¼ŒåŒ…å«äº†è¯¦ç»†çš„MQTTè¿æ¥ä¿¡æ¯ï¼š[DMS æ¥å…¥æ–¹å¼](https://gitlab.ovopark.com/device-shared-document/doc-dms/-/blob/master/09-%E8%AE%BE%E5%A4%87-DMS2-%E5%85%A5%E7%BD%91.md?ref_type=heads
    https://gitlab.ovopark.com/device-shared-document/doc-dms/-/blob/master/01-%E4%BF%A1%E4%BB%A4-DMS2-ALL-%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4.md?ref_type=heads
    https://gitlab.ovopark.com/device-shared-document/doc-dms/-/blob/master/06-%E6%8E%A8%E9%80%81-%E7%8A%B6%E6%80%81%E6%8E%A8%E9%80%81-DMS2-%E5%B7%A1%E5%BA%97%E5%A4%A7%E7%B1%BB.md?ref_type=heads)
  - ä½¿ç”¨Eclipse Paho MQTT Androidåº“ï¼šhttps://github.com/eclipse-paho/paho.mqtt.android

- ä»éœ€æ±‚åˆ†ææ¥çœ‹ï¼š

  - ä¸»è¦åœºæ™¯æ˜¯ç”¨æˆ·å¯åŠ¨Posæœºï¼Œå¯åŠ¨CloudPos APKï¼Œæ¥å…¥DMSå¹³å°ï¼ŒæœåŠ¡æä¾›æ–¹å¯ä»¥è§‚æµ‹åˆ°è®¾å¤‡å¯åŠ¨ä¸Šçº¿

  - éœ€è¦åœ¨APKç”Ÿå‘½å‘¨æœŸä¸­æŒç»­ç»´æŒè¿æ¥å’Œå¿ƒè·³

- ä»æŠ€æœ¯æ–‡æ¡£æ¥çœ‹ï¼Œæœ‰ä¸¤ä¸ªé˜¶æ®µï¼š

  - è¿æ¥é‡å®šå‘æœåŠ¡ï¼ˆssl://dms-dev.ovopark.com:8883ï¼‰
    - è¿›è¡Œè®¾å¤‡éªŒè¯å’Œå…¥ç½‘
    - è·å–çœŸæ­£çš„DMSæœåŠ¡åœ°å€
  - è¿æ¥çœŸæ­£çš„DMSæœåŠ¡ï¼ˆåœ°å€é€šè¿‡join_networkè·å–ï¼‰
    - è¿›è¡Œä¸»è®¾å¤‡ä¿¡æ¯ä¸ŠæŠ¥
    - ç»´æŒå¿ƒè·³è¿æ¥

- å®ç°æ€è·¯ï¼š

  - éœ€è¦è®¾å¤‡éªŒè¯ã€å…¥ç½‘ã€å¿ƒè·³ä¸ŠæŠ¥è¿™äº›åŠŸèƒ½ï¼Œ
  - åˆ†æ­¥å¼€å‘: å…ˆå®ç°åŸºç¡€MQTTè¿æ¥ï¼Œå†æ·»åŠ å¿ƒè·³é€»è¾‘

### 3.1 æ–¹æ¡ˆä¸€

- å®ç°æ€è·¯ï¼š
  
  - ä¼ ç»Ÿçš„Service + Manageræ¨¡å¼
  
  - A. åº”ç”¨å¯åŠ¨é˜¶æ®µ
  
    - MyApplication.onCreate() ä¸­åˆå§‹åŒ–DMSHeartbeatManager
  
    - å¯åŠ¨DMSMqttServiceå‰å°æœåŠ¡
  
    - å¼€å§‹ç¬¬ä¸€é˜¶æ®µè¿æ¥æµç¨‹
  
  - B. è¿è¡Œé˜¶æ®µ
  
    - ç»´æŒMQTTè¿æ¥
  
    - å®šæœŸå‘é€å¿ƒè·³ï¼ˆå»ºè®®30ç§’-1åˆ†é’Ÿé—´éš”ï¼‰
  
    - ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ–ï¼Œæ–­ç½‘é‡è¿
  
    - å¤„ç†æœåŠ¡ç«¯ä¸‹å‘çš„æ§åˆ¶æŒ‡ä»¤
  
  - C. å¼‚å¸¸å¤„ç†
  
    - è¿æ¥å¤±è´¥é‡è¯•æœºåˆ¶ï¼ˆæŒ‡æ•°é€€é¿ç­–ç•¥ï¼‰
  
    - ç½‘ç»œåˆ‡æ¢è‡ªåŠ¨é‡è¿
  
    - æœåŠ¡å¼‚å¸¸è‡ªåŠ¨é‡å¯
  
    - ç”µæ± ä¼˜åŒ–ç™½åå•å¼•å¯¼

### 3.2 æ–¹æ¡ˆäºŒ

- å®ç°æ€è·¯ï¼šâœ… çŠ¶æ€æœºé©±åŠ¨ + å“åº”å¼æµ + Clean Architecture
- åˆ†å±‚æ€è·¯ï¼š
  - DMSLifecycleService -> åªè´Ÿè´£ä¿æ´»
  - DMSConnectionUseCase -> åªè´Ÿè´£è¿æ¥ä¸šåŠ¡
  - DMSRepository -> åªè´Ÿè´£æ•°æ®ç®¡ç†
  - DMSStateMachine -> åªè´Ÿè´£çŠ¶æ€è½¬æ¢
  - MqttConnectionManager -> åªè´Ÿè´£MQTTè¿æ¥

## 04.å®ç°è§„åˆ’

### 4.1 æŠ€æœ¯é€‰å‹

- æ–¹æ¡ˆäºŒ

### 4.2 ä»»åŠ¡æ‹†è§£

- ç»“åˆå®é™…çš„ä¸šåŠ¡åœºæ™¯æ¥ç†è§£ï¼Œåœºæ™¯æè¿°ï¼šæ¥¼ä¸‹çš„äº‘å€¼å®ˆè´­ç‰©åº—ï¼Œæ—©ä¸Š8ç‚¹å¼€æœºå¯åŠ¨CloudPosåº”ç”¨ï¼Œéœ€è¦ç«‹å³è¿æ¥åˆ°DMSå¹³å°æŠ¥å‘Šè®¾å¤‡çŠ¶æ€ï¼Œç„¶åä¸€æ•´å¤©éƒ½è¦ç»´æŒå¿ƒè·³è¿æ¥ã€‚

- ç¬¬ä¸€å¹•ï¼šåº”ç”¨å¯åŠ¨

  - ```
    // MyApplication.kt - åº”ç”¨å¯åŠ¨æ—¶
    class MyApplication : Application() {
        override fun onCreate() {
            super.onCreate()
            
            // æŒ‰ä¸‹ç”µæºé”®ï¼ŒPOSæœºå¼€æœº
            LogManager.i("POSæœºæ­£åœ¨å¯åŠ¨...")
            
            // åˆå§‹åŒ–ä¾èµ–æ³¨å…¥
            startKoin {
                androidContext(this@MyApplication)
                modules(
                    networkModule,
                    appModule,
                    scannerModule,
                    dmsModule  // æ–°å¢DMSæ¨¡å—
                )
            }
            
            // å¯åŠ¨DMSå¿ƒè·³æœåŠ¡
            startDMSHeartbeatService()
        }
        
        private fun startDMSHeartbeatService() {
            LogManager.i("ğŸ”Œ å‡†å¤‡è¿æ¥DMSå¹³å°...")
            val intent = Intent(this, DMSLifecycleService::class.java)
            startForegroundService(intent)
        }
    }
    ```

  - å¼€åº—çš„ç¬¬ä¸€ä»¶äº‹æ˜¯å¯åŠ¨å‰å°æœåŠ¡ï¼Œæ‰€æœ‰çš„DMSç›¸å…³éƒ½åœ¨è¿™ä¸Šé¢è¿è¡Œï¼Œå®ƒçš„ç›®çš„æ˜¯ä¸ºäº†é¿å…activityåˆ‡æ¢å¯¼è‡´MQTTè¿æ¥ä¸­æ–­ï¼Œå³ï¼šä¿æŒåº”ç”¨ç”Ÿå‘½å‘¨æœŸå†…ï¼ŒMQTTéƒ½å­˜åœ¨ã€‚è‡³äºMQTTæ€ä¹ˆè¿æ¥ï¼Œè¿æ¥ä¸Šæ€ä¹ˆé€šè¯ï¼Œä¸å…³å®ƒçš„äº‹ï¼Œå®ƒåªè´Ÿè´£MQTTå¯ä»¥åœ¨åº”ç”¨ç”Ÿå‘½å‘¨æœŸå†…å­˜æ´»

- ç¬¬äºŒå¹•ï¼šå»ºç«‹è¿æ¥

  - ```
    // DMSLifecycleService.kt - ä¿æ´»æœåŠ¡
    class DMSLifecycleService : Service() {
        
        // é€šè¿‡ä¾èµ–æ³¨å…¥è·å–ä¸šåŠ¡ç»„ä»¶
        private val dmsConnectionUseCase: DMSConnectionUseCase by inject()
        private val serviceScope = CoroutineScope(Dispatchers.IO + SupervisorJob())
        
        override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
            LogManager.i("ğŸš€ DMSæœåŠ¡å¯åŠ¨ï¼Œå¼€å§‹å»ºç«‹è¿æ¥...")
            
            // åˆ›å»ºå‰å°é€šçŸ¥ï¼Œå‘Šè¯‰ç”¨æˆ·æ­£åœ¨è¿æ¥
            startForeground(NOTIFICATION_ID, createNotification("æ­£åœ¨è¿æ¥DMSå¹³å°..."))
            
            // å¯åŠ¨è¿æ¥æµç¨‹
            serviceScope.launch {
                dmsConnectionUseCase()
            }
            
            return START_STICKY // å¦‚æœè¢«æ€æ­»ï¼Œè‡ªåŠ¨é‡å¯
        }
        
        private fun createNotification(message: String): Notification {
            return NotificationCompat.Builder(this, "dms_channel")
                .setContentTitle("â˜• xxxä¾¿åˆ©åº—POS")
                .setContentText(message)
                .setSmallIcon(R.drawable.ic_pos)
                .build()
        }
    }
    
    
    // DMSConnectionUseCase.kt - è¿æ¥ä¸šåŠ¡ç”¨ä¾‹
    class DMSConnectionUseCase(
        private val dmsRepository: IDMSRepository,
        private val logManager: LogManager
    ) {
        suspend operator fun invoke(): Result<Unit> {
            logManager.i("â˜• å¼€å§‹ä¸ºxxxä¾¿åˆ©åº—å»ºç«‹DMSè¿æ¥...")
            
            return try {
                // å§”æ‰˜ç»™Repositoryæ‰§è¡Œå…·ä½“è¿æ¥
                dmsRepository.startConnection()
                logManager.i("âœ… xxxä¾¿åˆ©åº—å·²æˆåŠŸè¿æ¥DMSå¹³å°")
                Result.success(Unit)
            } catch (e: Exception) {
                logManager.e("âŒ xxxä¾¿åˆ©åº—è¿æ¥DMSå¤±è´¥: ${e.message}", e)
                Result.failure(e)
            }
        }
    }
    ```

  - å»ºç«‹è¿æ¥çš„è¿‡ç¨‹æ˜¯ä¸ºäº†ä¿è¯MQTTä¸æ–­çº¿ï¼Œä¹Ÿå°±æ˜¯ç”µè¯ä¸æ–­çº¿ï¼Œå…·ä½“æ‰“ä»€ä¹ˆç”µè¯ï¼Œè¯´ä»€ä¹ˆè¯ï¼Œéƒ½äº¤ç»™å…¶ä»–äººåš

  - è¿™é‡Œå‰å°æœåŠ¡è°ƒç”¨çš„æ˜¯dmsConnectionUseCaseï¼Œå®é™…å†…å®¹åœ¨dmsConnectionUseCaseä¸­å°è£…å®Œæˆ

- ç¬¬ä¸‰å¹•ï¼šçŠ¶æ€æœºé©±åŠ¨çš„è¿æ¥è¿‡ç¨‹

  - ```
    // DMSRepository.kt - æ ¸å¿ƒä¸šåŠ¡å®ç°
    class DMSRepository(
        private val stateMachine: DMSStateMachine,
        private val connectionManager: MqttConnectionManager,
        private val deviceInfoProvider: DeviceInfoProvider
    ) : IDMSRepository {
        
        // è¿æ¥çŠ¶æ€ï¼ŒUIå¯ä»¥è§‚å¯Ÿ
        override val connectionState: StateFlow<DMSConnectionState> = stateMachine.state
        
        override suspend fun startConnection(): Result<Unit> = withContext(Dispatchers.IO) {
            logManager.i("ğŸ“± å¼€å§‹DMSè¿æ¥æµç¨‹...")
            
            try {
                // ç¬¬ä¸€æ­¥ï¼šå‡†å¤‡è®¾å¤‡ä¿¡æ¯
                val deviceId = deviceInfoProvider.getDeviceId()
                logManager.i("ğŸ†” xxxä¾¿åˆ©åº—è®¾å¤‡ID: $deviceId")
                
                // ç¬¬äºŒæ­¥ï¼šçŠ¶æ€æœºå¼€å§‹å·¥ä½œ
                stateMachine.transition(DMSEvent.StartConnection)
                
                // ç¬¬ä¸‰æ­¥ï¼šä¸¤é˜¶æ®µè¿æ¥
                performTwoPhaseConnection(deviceId)
                
                Result.success(Unit)
            } catch (e: Exception) {
                stateMachine.transition(DMSEvent.ConnectionFailed(e))
                Result.failure(e)
            }
        }
        
        private suspend fun performTwoPhaseConnection(deviceId: String) {
            // é˜¶æ®µ1ï¼šè¿æ¥é‡å®šå‘æœåŠ¡å™¨
            logManager.i("ğŸ”„ ç¬¬ä¸€é˜¶æ®µï¼šè¿æ¥é‡å®šå‘æœåŠ¡å™¨...")
            stateMachine.transition(DMSEvent.ConnectingToRedirect)
            
            val redirectResult = connectionManager.connectToRedirectServer(deviceId)
            val dmsServerUrl = redirectResult.getOrThrow()
            
            logManager.i("ğŸ“ è·å¾—çœŸå®DMSæœåŠ¡å™¨åœ°å€: $dmsServerUrl")
            
            // é˜¶æ®µ2ï¼šè¿æ¥çœŸå®DMSæœåŠ¡å™¨
            logManager.i("ğŸ¯ ç¬¬äºŒé˜¶æ®µï¼šè¿æ¥çœŸå®DMSæœåŠ¡å™¨...")
            stateMachine.transition(DMSEvent.ConnectingToDMS)
            
            connectionManager.connectToDMSServer(dmsServerUrl, deviceId)
            
            // é˜¶æ®µ3ï¼šå¼€å§‹å¿ƒè·³
            logManager.i("ğŸ’“ ç¬¬ä¸‰é˜¶æ®µï¼šå¯åŠ¨å¿ƒè·³æœºåˆ¶...")
            stateMachine.transition(DMSEvent.HeartbeatStarted)
            
            startHeartbeat(deviceId)
        }
        
        private suspend fun startHeartbeat(deviceId: String) {
            // æ¯30ç§’å‘é€ä¸€æ¬¡å¿ƒè·³
            while (stateMachine.state.value is DMSConnectionState.HeartbeatActive) {
                delay(30_000) // 30ç§’é—´éš”
                
                try {
                    val heartbeatData = deviceInfoProvider.createHeartbeatData()
                    connectionManager.sendHeartbeat(heartbeatData)
                    logManager.i("ğŸ’“ xxxä¾¿åˆ©åº—å¿ƒè·³å‘é€æˆåŠŸ")
                } catch (e: Exception) {
                    logManager.e("ğŸ’” å¿ƒè·³å‘é€å¤±è´¥", e)
                    stateMachine.transition(DMSEvent.HeartbeatFailed(e))
                }
            }
        }
    }
    ```

  - é˜¶æ®µ1ï¼šå…ˆæ‰“æ€»æœºé—®"æˆ‘è¦è”ç³»è®¾å¤‡ç®¡ç†éƒ¨é—¨"ï¼Œæ€»æœºå‘Šè¯‰ä½ "è½¬123åˆ†æœº"

  - é˜¶æ®µ2ï¼šæ‹¨æ‰“123åˆ†æœºï¼Œè¯´"æˆ‘æ˜¯XXä¾¿åˆ©åº—ï¼Œè®¾å¤‡IDæ˜¯ABC123ï¼Œç°åœ¨å¼€å§‹è¥ä¸š"

  - é˜¶æ®µ3ï¼šæ¯30åˆ†é’Ÿç»™æ€»éƒ¨æ‰“ç”µè¯è¯´"æˆ‘è¿˜åœ¨æ­£å¸¸è¥ä¸š"

- ç¬¬å››å¹•ï¼šçŠ¶æ€æœºçš„å·¥ä½œåŸç†

  - ```
    // DMSStateMachine.kt - çŠ¶æ€æœº
    class DMSStateMachine {
        private val _state = MutableStateFlow<DMSConnectionState>(DMSConnectionState.Idle)
        val state: StateFlow<DMSConnectionState> = _state.asStateFlow()
        
        fun transition(event: DMSEvent) {
            val currentState = _state.value
            val newState = when (currentState to event) {
                
                // ä»ç©ºé—²çŠ¶æ€å¼€å§‹è¿æ¥
                DMSConnectionState.Idle to DMSEvent.StartConnection -> {
                    LogManager.i("ğŸª xxxä¾¿åˆ©åº—ä»ã€ç©ºé—²ã€‘å˜ä¸ºã€è¿æ¥é‡å®šå‘æœåŠ¡å™¨ã€‘")
                    DMSConnectionState.ConnectingToRedirect
                }
                
                // é‡å®šå‘è¿æ¥æˆåŠŸ
                DMSConnectionState.ConnectingToRedirect to DMSEvent.RedirectConnected -> {
                    LogManager.i("ğŸ”„ ä»ã€è¿æ¥é‡å®šå‘ã€‘å˜ä¸ºã€ç­‰å¾…çœŸå®æœåŠ¡å™¨ä¿¡æ¯ã€‘")
                    DMSConnectionState.WaitingForNetworkInfo
                }
                
                // å¼€å§‹è¿æ¥DMSæœåŠ¡å™¨
                DMSConnectionState.WaitingForNetworkInfo to DMSEvent.ConnectingToDMS -> {
                    LogManager.i("ğŸ¯ ä»ã€ç­‰å¾…ä¿¡æ¯ã€‘å˜ä¸ºã€è¿æ¥DMSæœåŠ¡å™¨ã€‘")
                    DMSConnectionState.ConnectingToDMS
                }
                
                // DMSè¿æ¥æˆåŠŸï¼Œå¼€å§‹å¿ƒè·³
                DMSConnectionState.ConnectingToDMS to DMSEvent.HeartbeatStarted -> {
                    LogManager.i("ğŸ’“ ä»ã€è¿æ¥DMSã€‘å˜ä¸ºã€å¿ƒè·³æ¿€æ´»ã€‘")
                    DMSConnectionState.HeartbeatActive
                }
                
                // ä»»ä½•çŠ¶æ€é‡åˆ°é”™è¯¯
                else to DMSEvent.ConnectionFailed(exception) -> {
                    LogManager.e("ğŸ’¥ è¿æ¥å¤±è´¥ï¼Œè¿›å…¥é”™è¯¯çŠ¶æ€: ${exception.message}")
                    DMSConnectionState.Error(exception)
                }
                
                else -> {
                    LogManager.w("âš ï¸ æ— æ•ˆçš„çŠ¶æ€è½¬æ¢: $currentState -> $event")
                    currentState // ä¿æŒåŸçŠ¶æ€
                }
            }
            
            _state.value = newState
        }
    }
    
    // çŠ¶æ€å®šä¹‰
    sealed class DMSConnectionState {
        object Idle : DMSConnectionState()                    // ç©ºé—²ï¼šåˆšå¯åŠ¨
        object ConnectingToRedirect : DMSConnectionState()    // è¿æ¥é‡å®šå‘æœåŠ¡å™¨
        object WaitingForNetworkInfo : DMSConnectionState()   // ç­‰å¾…çœŸå®æœåŠ¡å™¨ä¿¡æ¯
        object ConnectingToDMS : DMSConnectionState()         // è¿æ¥DMSæœåŠ¡å™¨
        object HeartbeatActive : DMSConnectionState()         // å¿ƒè·³æ¿€æ´»
        data class Error(val exception: Throwable) : DMSConnectionState() // é”™è¯¯çŠ¶æ€
    }
    
    // äº‹ä»¶å®šä¹‰
    sealed class DMSEvent {
        object StartConnection : DMSEvent()
        object RedirectConnected : DMSEvent()
        object ConnectingToDMS : DMSEvent()
        object HeartbeatStarted : DMSEvent()
        data class ConnectionFailed(val exception: Throwable) : DMSEvent()
    }
    ```

  - ç°å®åœºæ™¯è§£é‡Šï¼šçŠ¶æ€æœºå°±åƒä¸€ä¸ªä¸¥æ ¼çš„æµç¨‹å›¾ï¼š

    - å½“å‰çŠ¶æ€ï¼šä¾¿åˆ©åº—ç°åœ¨åœ¨åšä»€ä¹ˆ

    - äº‹ä»¶ï¼šå‘ç”Ÿäº†ä»€ä¹ˆæƒ…å†µ

    - è½¬æ¢ï¼šæ ¹æ®å½“å‰çŠ¶æ€å’Œå‘ç”Ÿçš„äº‹ä»¶ï¼Œå†³å®šä¸‹ä¸€æ­¥è¯¥åšä»€ä¹ˆ

    å°±åƒï¼šå¦‚æœä½ åœ¨"æ‹¨æ‰“æ€»æœº"çŠ¶æ€ï¼Œæ”¶åˆ°"æ€»æœºæ¥é€š"äº‹ä»¶ï¼Œå°±è½¬æ¢åˆ°"è¯¢é—®åˆ†æœºå·"çŠ¶æ€ã€‚

- ç¬¬äº”å¹•ï¼šå…·ä½“çš„MQTTè¿æ¥ï¼Œå°±æ˜¯ç¬¬ä¸‰å¹•çš„å®é™…å®ç°

  - ```
    // MqttConnectionManager.kt - MQTTè¿æ¥ç®¡ç†
    class MqttConnectionManager(
        private val deviceInfoProvider: DeviceInfoProvider
    ) {
        private var mqttClient: MqttAndroidClient? = null
        
        suspend fun connectToRedirectServer(deviceId: String): Result<String> = withContext(Dispatchers.IO) {
            LogManager.i("ğŸ“ æ­£åœ¨æ‹¨æ‰“DMSé‡å®šå‘æœåŠ¡å™¨...")
            
            try {
                // 1. åˆ›å»ºMQTTå®¢æˆ·ç«¯
                val redirectUrl = "ssl://dms-dev.ovopark.com:8883"
                mqttClient = MqttAndroidClient(context, redirectUrl, deviceId)
                
                // 2. è®¾ç½®è¿æ¥å‚æ•°
                val connectOptions = MqttConnectOptions().apply {
                    userName = deviceId
                    password = generatePassword(deviceId).toCharArray()
                    isCleanSession = true
                    connectionTimeout = 30
                    keepAliveInterval = 60
                }
                
                LogManager.i("ğŸ”‘ è®¤è¯ä¿¡æ¯ - ç”¨æˆ·å: $deviceId, å¯†ç : ${generatePassword(deviceId)}")
                
                // 3. è¿æ¥
                val token = mqttClient!!.connect(connectOptions)
                token.waitForCompletion(30000) // ç­‰å¾…30ç§’
                
                LogManager.i("âœ… é‡å®šå‘æœåŠ¡å™¨è¿æ¥æˆåŠŸ")
                
                // 4. è®¢é˜…ä¸»é¢˜ï¼Œç­‰å¾…çœŸå®æœåŠ¡å™¨ä¿¡æ¯
                val joinNetworkTopic = "/elogger/$deviceId/join_network"
                mqttClient!!.subscribe(joinNetworkTopic, 1)
                LogManager.i("ğŸ‘‚ å¼€å§‹ç›‘å¬å…¥ç½‘ä¿¡æ¯: $joinNetworkTopic")
                
                // 5. æ¨¡æ‹Ÿç­‰å¾…æœåŠ¡å™¨è¿”å›çœŸå®åœ°å€
                delay(2000) // å®é™…åº”è¯¥ç­‰å¾…æ¶ˆæ¯
                val realDMSUrl = "ssl://dms2-test-001.ovopark.com:8883"
                
                LogManager.i("ğŸ“ æ”¶åˆ°çœŸå®DMSæœåŠ¡å™¨åœ°å€: $realDMSUrl")
                Result.success(realDMSUrl)
                
            } catch (e: Exception) {
                LogManager.e("âŒ é‡å®šå‘æœåŠ¡å™¨è¿æ¥å¤±è´¥", e)
                Result.failure(e)
            }
        }
        
        suspend fun connectToDMSServer(dmsUrl: String, deviceId: String): Result<Unit> = withContext(Dispatchers.IO) {
            LogManager.i("ğŸ¯ æ­£åœ¨è¿æ¥çœŸå®DMSæœåŠ¡å™¨: $dmsUrl")
            
            try {
                // æ–­å¼€é‡å®šå‘è¿æ¥
                mqttClient?.disconnect()
                
                // è¿æ¥çœŸå®DMSæœåŠ¡å™¨
                mqttClient = MqttAndroidClient(context, dmsUrl, deviceId)
                
                val connectOptions = MqttConnectOptions().apply {
                    userName = deviceId
                    password = generatePassword(deviceId).toCharArray() // é‡æ–°ç”Ÿæˆå¯†ç 
                    isCleanSession = true
                }
                
                val token = mqttClient!!.connect(connectOptions)
                token.waitForCompletion(30000)
                
                LogManager.i("âœ… DMSæœåŠ¡å™¨è¿æ¥æˆåŠŸï¼Œå¯ä»¥å¼€å§‹å¿ƒè·³")
                Result.success(Unit)
                
            } catch (e: Exception) {
                LogManager.e("âŒ DMSæœåŠ¡å™¨è¿æ¥å¤±è´¥", e)
                Result.failure(e)
            }
        }
        
        suspend fun sendHeartbeat(heartbeatData: String): Result<Unit> = withContext(Dispatchers.IO) {
            try {
                val topic = "/monitor/report/Sync_MainDeviceInfo"
                mqttClient!!.publish(topic, heartbeatData.toByteArray(), 1, false)
                LogManager.i("ğŸ’“ å¿ƒè·³å‘é€æˆåŠŸ: $heartbeatData")
                Result.success(Unit)
            } catch (e: Exception) {
                LogManager.e("ğŸ’” å¿ƒè·³å‘é€å¤±è´¥", e)
                Result.failure(e)
            }
        }
        
        // ç”Ÿæˆè®¤è¯å¯†ç 
        private fun generatePassword(clientId: String): String {
            val timestamp = System.currentTimeMillis() / 1000 / 100 // ç§’/100
            val raw = "ovopark_${clientId}_${timestamp}"
            return raw.md5() // éœ€è¦MD5åŠ å¯†
        }
    }
    ```

  - ç°å®åœºæ™¯è§£é‡Šï¼š

    - connectToRedirectServerï¼šæ‹¨æ‰“æ€»æœºï¼Œé—®"æˆ‘è¦è”ç³»è®¾å¤‡ç®¡ç†éƒ¨"
- connectToDMSServerï¼šæ‹¨æ‰“çœŸæ­£çš„åˆ†æœºå·
    
- sendHeartbeatï¼šæ¯éš”30åˆ†é’Ÿè¯´"æˆ‘æ˜¯XXä¾¿åˆ©åº—ï¼Œä¸€åˆ‡æ­£å¸¸"
    
- ç¬¬å…­å¹•ï¼šç½‘ç»œçŠ¶æ€ç›‘æ§ (NetworkStateMonitor)

  - ```
    class NetworkStateMonitor(private val context: Context) {
        
        private val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        private val _networkState = MutableStateFlow(NetworkState.Unknown)
        val networkState: StateFlow<NetworkState> = _networkState.asStateFlow()
        
        // ç½‘ç»œçŠ¶æ€å®šä¹‰
        sealed class NetworkState {
            object Unknown : NetworkState()
            object Disconnected : NetworkState()
            data class Connected(
                val type: NetworkType,
                val quality: NetworkQuality
            ) : NetworkState()
            data class Switching(
                val from: NetworkType,
                val to: NetworkType
            ) : NetworkState()
        }
        
        enum class NetworkType { WIFI, ETHERNET, MOBILE, UNKNOWN }
        enum class NetworkQuality { EXCELLENT, GOOD, POOR, VERY_POOR }
        
        private var networkCallback: ConnectivityManager.NetworkCallback? = null
        
        fun startMonitoring() {
            LogManager.i("ğŸŒ å¼€å§‹ç›‘æ§ç½‘ç»œçŠ¶æ€å˜åŒ–...")
            
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                registerNetworkCallback()
            } else {
                startLegacyNetworkMonitoring()
            }
        }
        
        @RequiresApi(Build.VERSION_CODES.N)
        private fun registerNetworkCallback() {
            val networkRequest = NetworkRequest.Builder()
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                .addTransportType(NetworkCapabilities.TRANSPORT_ETHERNET)
                .build()
                
            networkCallback = object : ConnectivityManager.NetworkCallback() {
                override fun onAvailable(network: Network) {
                    LogManager.i("ğŸŒ ç½‘ç»œè¿æ¥å¯ç”¨: ${network}")
                    val networkType = getNetworkType(network)
                    val quality = assessNetworkQuality(network)
                    
                    _networkState.value = NetworkState.Connected(networkType, quality)
                }
                
                override fun onLost(network: Network) {
                    LogManager.w("ğŸŒ ç½‘ç»œè¿æ¥ä¸¢å¤±: ${network}")
                    _networkState.value = NetworkState.Disconnected
                }
                
                override fun onCapabilitiesChanged(network: Network, capabilities: NetworkCapabilities) {
                    val quality = assessNetworkQuality(network, capabilities)
                    val currentState = _networkState.value
                    
                    if (currentState is NetworkState.Connected) {
                        _networkState.value = currentState.copy(quality = quality)
                    }
                }
                
                override fun onLinkPropertiesChanged(network: Network, linkProperties: LinkProperties) {
                    LogManager.i("ğŸŒ ç½‘ç»œå±æ€§å˜åŒ–: ${linkProperties.interfaceName}")
                    detectNetworkSwitching(network, linkProperties)
                }
            }
            
            connectivityManager.registerNetworkCallback(networkRequest, networkCallback!!)
        }
        
        private fun detectNetworkSwitching(network: Network, linkProperties: LinkProperties) {
            val currentState = _networkState.value
            if (currentState is NetworkState.Connected) {
                val newType = getNetworkType(network)
                if (newType != currentState.type) {
                    LogManager.i("ğŸ”„ æ£€æµ‹åˆ°ç½‘ç»œåˆ‡æ¢: ${currentState.type} â†’ ${newType}")
                    _networkState.value = NetworkState.Switching(currentState.type, newType)
                    
                    // å»¶è¿Ÿæ›´æ–°åˆ°æ–°çš„è¿æ¥çŠ¶æ€
                    CoroutineScope(Dispatchers.IO).launch {
                        delay(2000) // ç­‰å¾…ç½‘ç»œç¨³å®š
                        val quality = assessNetworkQuality(network)
                        _networkState.value = NetworkState.Connected(newType, quality)
                    }
                }
            }
        }
        
        fun stopMonitoring() {
            networkCallback?.let {
                connectivityManager.unregisterNetworkCallback(it)
            }
            LogManager.i("ğŸŒ åœæ­¢ç½‘ç»œçŠ¶æ€ç›‘æ§")
        }
    }
    ```

    **èŒè´£**ï¼šå®æ—¶ç›‘æ§ç½‘ç»œçŠ¶æ€å˜åŒ–ï¼Œä¸ºé‡è¿æä¾›ä¾æ®

- ç¬¬ä¸ƒå¹•ï¼šé‡è”ç®¡ç†å™¨

  - ```
    class ReconnectionManager(
        private val dmsRepository: IDMSRepository,
        private val networkStateMonitor: NetworkStateMonitor
    ) {
        
        data class ReconnectionConfig(
            val maxRetryAttempts: Int = 10,
            val initialDelayMs: Long = 1000L,        // 1ç§’
            val maxDelayMs: Long = 300_000L,         // 5åˆ†é’Ÿ
            val backoffMultiplier: Double = 2.0,
            val jitterFactor: Double = 0.1           // 10%éšæœºæŠ–åŠ¨
        )
        
        private val config = ReconnectionConfig()
        private var currentRetryCount = 0
        private var reconnectionJob: Job? = null
        private val random = Random()
        
        // é‡è¿çŠ¶æ€
        sealed class ReconnectionState {
            object Idle : ReconnectionState()
            data class Retrying(val attempt: Int, val nextDelayMs: Long) : ReconnectionState()
            object WaitingForNetwork : ReconnectionState()
            data class Failed(val reason: String) : ReconnectionState()
        }
        
        private val _reconnectionState = MutableStateFlow<ReconnectionState>(ReconnectionState.Idle)
        val reconnectionState: StateFlow<ReconnectionState> = _reconnectionState.asStateFlow()
        
        fun startReconnection(reason: ConnectionFailureReason) {
            LogManager.i("ğŸ”„ å¼€å§‹é‡è¿æµç¨‹ï¼ŒåŸå› : $reason")
            
            when (reason) {
                ConnectionFailureReason.NETWORK_UNAVAILABLE -> waitForNetworkAndReconnect()
                ConnectionFailureReason.SERVER_UNREACHABLE -> startExponentialBackoffReconnection()
                ConnectionFailureReason.AUTHENTICATION_FAILED -> handleAuthenticationFailure()
                ConnectionFailureReason.PROTOCOL_ERROR -> resetAndReconnect()
            }
        }
        
        private fun startExponentialBackoffReconnection() {
            reconnectionJob?.cancel()
            
            reconnectionJob = CoroutineScope(Dispatchers.IO).launch {
                while (currentRetryCount < config.maxRetryAttempts) {
                    currentRetryCount++
                    
                    val baseDelay = (config.initialDelayMs * 
                        config.backoffMultiplier.pow(currentRetryCount - 1)).toLong()
                    val cappedDelay = minOf(baseDelay, config.maxDelayMs)
                    
                    // æ·»åŠ éšæœºæŠ–åŠ¨é¿å…é›·ç¾¤æ•ˆåº”
                    val jitter = (cappedDelay * config.jitterFactor * (random.nextDouble() - 0.5)).toLong()
                    val actualDelay = cappedDelay + jitter
                    
                    _reconnectionState.value = ReconnectionState.Retrying(currentRetryCount, actualDelay)
                    
                    LogManager.i("ğŸ”„ ç¬¬${currentRetryCount}æ¬¡é‡è¿å°è¯•ï¼Œ${actualDelay}msåå¼€å§‹...")
                    delay(actualDelay)
                    
                    try {
                        val result = dmsRepository.startConnection()
                        if (result.isSuccess) {
                            LogManager.i("âœ… é‡è¿æˆåŠŸï¼")
                            resetReconnectionState()
                            return@launch
                        } else {
                            LogManager.w("âŒ ç¬¬${currentRetryCount}æ¬¡é‡è¿å¤±è´¥: ${result.exceptionOrNull()?.message}")
                        }
                    } catch (e: Exception) {
                        LogManager.e("ğŸ’¥ é‡è¿è¿‡ç¨‹ä¸­å‘ç”Ÿå¼‚å¸¸", e)
                    }
                }
                
                // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†
                LogManager.e("ğŸ’” é‡è¿å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°")
                _reconnectionState.value = ReconnectionState.Failed("å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°")
            }
        }
    }
    
    enum class ConnectionFailureReason {
        NETWORK_UNAVAILABLE,      // ç½‘ç»œä¸å¯ç”¨
        SERVER_UNREACHABLE,       // æœåŠ¡å™¨ä¸å¯è¾¾
        AUTHENTICATION_FAILED,    // è®¤è¯å¤±è´¥
        PROTOCOL_ERROR           // åè®®é”™è¯¯
    }
    ```

    **èŒè´£**ï¼šå®ç°æŒ‡æ•°é€€é¿é‡è¿ç­–ç•¥ï¼Œå¤„ç†ä¸åŒç±»å‹çš„è¿æ¥å¤±è´¥

- ç¬¬å…«å¹•ï¼šæŒ‡ä»¤ç®¡ç†å™¨

  - ```
    class CommandProcessor(
        private val context: Context,
        private val mqttConnectionManager: MqttConnectionManager
    ) {
        
        // æ”¯æŒçš„æŒ‡ä»¤ç±»å‹
        sealed class DMSCommand {
            abstract val commandId: String
            abstract val timestamp: Long
            
            data class RebootDevice(
                override val commandId: String,
                override val timestamp: Long,
                val delaySeconds: Int = 0
            ) : DMSCommand()
            
            data class FactoryReset(
                override val commandId: String,
                override val timestamp: Long,
                val confirmationCode: String
            ) : DMSCommand()
            
            data class UpdateConfig(
                override val commandId: String,
                override val timestamp: Long,
                val configData: Map<String, Any>
            ) : DMSCommand()
            
            data class HealthCheck(
                override val commandId: String,
                override val timestamp: Long
            ) : DMSCommand()
        }
        
        // æŒ‡ä»¤æ‰§è¡Œç»“æœ
        data class CommandResult(
            val commandId: String,
            val success: Boolean,
            val message: String,
            val data: Map<String, Any> = emptyMap(),
            val executionTimeMs: Long
        )
        
        suspend fun processCommand(commandJson: String): CommandResult {
            return try {
                val startTime = System.currentTimeMillis()
                
                LogManager.i("ğŸ“¡ æ”¶åˆ°DMSæŒ‡ä»¤: $commandJson")
                
                // è§£ææŒ‡ä»¤
                val command = parseCommand(commandJson)
                LogManager.i("ğŸ“¡ è§£ææŒ‡ä»¤: ${command::class.simpleName}, ID: ${command.commandId}")
                
                // æ‰§è¡ŒæŒ‡ä»¤
                val result = when (command) {
                    is DMSCommand.RebootDevice -> handleRebootDevice(command)
                    is DMSCommand.FactoryReset -> handleFactoryReset(command)
                    is DMSCommand.UpdateConfig -> handleUpdateConfig(command)
                    is DMSCommand.HealthCheck -> handleHealthCheck(command)
                }
                
                // å‘é€æ‰§è¡Œç»“æœ
                sendCommandResponse(result)
                
                LogManager.i("ğŸ“¡ æŒ‡ä»¤æ‰§è¡Œå®Œæˆ: ${result}")
                result
                
            } catch (e: Exception) {
                LogManager.e("ğŸ“¡ æŒ‡ä»¤å¤„ç†å¤±è´¥", e)
                CommandResult(
                    commandId = "unknown",
                    success = false,
                    message = "æŒ‡ä»¤å¤„ç†å¼‚å¸¸: ${e.message}",
                    executionTimeMs = 0
                )
            }
        }
        
        private suspend fun handleHealthCheck(command: DMSCommand.HealthCheck): CommandResult {
            LogManager.i("ğŸ’Š æ‰§è¡Œå¥åº·æ£€æŸ¥æŒ‡ä»¤")
            
            val startTime = System.currentTimeMillis()
            
            val healthData = mutableMapOf<String, Any>()
            
            // æ£€æŸ¥ç³»ç»Ÿä¿¡æ¯
            healthData["battery_level"] = getBatteryLevel()
            healthData["memory_usage"] = getMemoryUsage()
            healthData["storage_usage"] = getStorageUsage()
            healthData["network_status"] = getNetworkStatus()
            healthData["app_version"] = getAppVersion()
            healthData["system_uptime"] = getSystemUptime()
            healthData["cpu_usage"] = getCpuUsage()
            
            // æ£€æŸ¥å…³é”®æœåŠ¡çŠ¶æ€
            healthData["mqtt_connected"] = mqttConnectionManager.isConnected()
            healthData["scanner_status"] = getScannerStatus()
            healthData["payment_service_status"] = getPaymentServiceStatus()
            
            return CommandResult(
                commandId = command.commandId,
                success = true,
                message = "å¥åº·æ£€æŸ¥å®Œæˆ",
                data = healthData,
                executionTimeMs = System.currentTimeMillis() - startTime
            )
        }
    }
    ```

    **èŒè´£**ï¼šå¤„ç†æœåŠ¡ç«¯ä¸‹å‘çš„æ§åˆ¶æŒ‡ä»¤ï¼Œæ‰§è¡Œè®¾å¤‡ç®¡ç†æ“ä½œ

- ç¬¬ä¹å¹•ï¼šè®¾å¤‡ä¿¡æ¯æä¾›

  - ```
    // DeviceInfoProvider.kt - è®¾å¤‡ä¿¡æ¯æä¾›è€…
    class DeviceInfoProvider(private val context: Context) {
        
        fun getDeviceId(): String {
            // POSæœºç¼–å·
            return Settings.Secure.getString(context.contentResolver, Settings.Secure.ANDROID_ID)
                ?: "COFFEE_SHOP_POS_001"
        }
        
        fun createHeartbeatData(): String {
            val deviceInfo = JSONObject().apply {
                put("deviceId", getDeviceId())
                put("shopName", "XXä¾¿åˆ©åº—")
                put("location", "è‹å·å¸‚å´ä¸­åŒº")
                put("status", "ONLINE")
                put("timestamp", System.currentTimeMillis())
                put("batteryLevel", getBatteryLevel())
                put("networkType", getNetworkType())
                put("runningApps", getRunningApps())
            }
            
            LogManager.i("ğŸ“Š è®¾å¤‡çŠ¶æ€æŠ¥å‘Š: $deviceInfo")
            return deviceInfo.toString()
        }
        
        private fun getBatteryLevel(): Int {
            // è·å–ç”µæ± ç”µé‡
            val batteryManager = context.getSystemService(Context.BATTERY_SERVICE) as BatteryManager
            return batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)
        }
        
        private fun getNetworkType(): String {
            val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
            val network = connectivityManager.activeNetwork
            val capabilities = connectivityManager.getNetworkCapabilities(network)
            
            return when {
                capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) == true -> "WIFI"
                capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET) == true -> "ETHERNET"
                else -> "UNKNOWN"
            }
        }
        
        private fun getRunningApps(): List<String> {
            // è¿”å›å½“å‰è¿è¡Œçš„å…³é”®åº”ç”¨
            return listOf("CloudPos", "ç³»ç»Ÿç›‘æ§")
        }
    }
    ```

  - ç°å®åœºæ™¯è§£é‡Šï¼šå°±åƒåº—å‘˜å‘æ€»éƒ¨æ±‡æŠ¥æ—¶è¯´ï¼š

    - "æˆ‘æ˜¯xxxä¾¿åˆ©åº—001å·æœº"

    - "å½“å‰æ—¶é—´10:30"

    - "ç”µé‡85%"

    - "ç½‘ç»œæ­£å¸¸"

    - "æ”¶é“¶ç³»ç»Ÿè¿è¡Œæ­£å¸¸"

- ç¬¬ä¸ƒå¹•ï¼šUIå±‚è§‚å¯ŸçŠ¶æ€

  - ```
    // MainActivity.kt - ä¸»ç•Œé¢
    class MainActivity : AppCompatActivity() {
        
        private val dmsRepository: IDMSRepository by inject()
        
        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContentView(R.layout.activity_main)
            
            // è§‚å¯ŸDMSè¿æ¥çŠ¶æ€
            observeDMSStatus()
        }
        
        private fun observeDMSStatus() {
            lifecycleScope.launch {
                dmsRepository.connectionState.collect { state ->
                    when (state) {
                        is DMSConnectionState.Idle -> {
                            showStatus("â¸ï¸ ç³»ç»Ÿç©ºé—²", Color.GRAY)
                        }
                        is DMSConnectionState.ConnectingToRedirect -> {
                            showStatus("ğŸ”„ æ­£åœ¨è¿æ¥æ€»éƒ¨...", Color.ORANGE)
                        }
                        is DMSConnectionState.ConnectingToDMS -> {
                            showStatus("ğŸ¯ æ­£åœ¨æ¥å…¥ç›‘æ§ç³»ç»Ÿ...", Color.BLUE)
                        }
                        is DMSConnectionState.HeartbeatActive -> {
                            showStatus("âœ… å·²è¿æ¥ | å¿ƒè·³æ­£å¸¸", Color.GREEN)
                            showLastHeartbeat()
                        }
                        is DMSConnectionState.Error -> {
                            showStatus("âŒ è¿æ¥å¤±è´¥: ${state.exception.message}", Color.RED)
                            showRetryButton()
                        }
                    }
                }
            }
        }
        
        private fun showStatus(message: String, color: Int) {
            runOnUiThread {
                statusText.text = message
                statusText.setTextColor(color)
                LogManager.i("ğŸ–¥ï¸ UIçŠ¶æ€æ›´æ–°: $message")
            }
        }
        
        private fun showLastHeartbeat() {
            lifecycleScope.launch {
                while (dmsRepository.connectionState.value is DMSConnectionState.HeartbeatActive) {
                    delay(1000) // æ¯ç§’æ›´æ–°
                    val now = SimpleDateFormat("HH:mm:ss", Locale.getDefault()).format(Date())
                    heartbeatText.text = "æœ€åå¿ƒè·³: $now"
                }
            }
        }
    }
    ```

  - ç°å®åœºæ™¯è§£é‡Šï¼šå°±åƒxxxä¾¿åˆ©åº—çš„æ˜¾ç¤ºå±ï¼Œå®æ—¶æ˜¾ç¤ºï¼š

    - "æ­£åœ¨è¿æ¥æ€»éƒ¨..." (æ©™è‰²)
- "å·²è¿æ¥ | å¿ƒè·³æ­£å¸¸" (ç»¿è‰²)
    
    - "è¿æ¥å¤±è´¥" (çº¢è‰²)

### 4.3 ä¸ºä»€ä¹ˆè¦è¿™æ ·è®¾è®¡

- ä¼ ç»Ÿæ–¹å¼çš„é—®é¢˜

  ```
  // âŒ ä¼ ç»Ÿåšæ³•ï¼šæ‰€æœ‰é€»è¾‘éƒ½åœ¨Serviceé‡Œ
  class OldMqttService : Service() {
      override fun onStartCommand() {
          // è¿æ¥é€»è¾‘
          // å¿ƒè·³é€»è¾‘  
          // é”™è¯¯å¤„ç†
          // UIæ›´æ–°
          // ç½‘ç»œç›‘æ§
          // æŒ‡ä»¤å¤„ç†
          // å…¨éƒ¨æ··åœ¨ä¸€èµ·ï¼Œéš¾ä»¥æµ‹è¯•å’Œç»´æŠ¤
      }
  }
  ```

- æ–°æ¶æ„çš„ä¼˜åŠ¿

  ```
  // âœ… æ–°åšæ³•ï¼šæ¯ä¸ªç»„ä»¶èŒè´£å•ä¸€
  DMSLifecycleService -> åªè´Ÿè´£ä¿æ´»
  DMSConnectionUseCase -> åªè´Ÿè´£è¿æ¥ä¸šåŠ¡
  DMSRepository -> åªè´Ÿè´£æ•°æ®ç®¡ç†
  DMSStateMachine -> åªè´Ÿè´£çŠ¶æ€è½¬æ¢
  MqttConnectionManager -> åªè´Ÿè´£MQTTè¿æ¥
  NetworkStateMonitor -> åªè´Ÿè´£ç½‘ç»œç›‘æ§
  ReconnectionManager -> åªè´Ÿè´£é‡è¿ç­–ç•¥
  CommandProcessor -> åªè´Ÿè´£æŒ‡ä»¤å¤„ç†
  ExceptionHandler -> åªè´Ÿè´£å¼‚å¸¸æ¢å¤
  ServiceWatchdog -> åªè´Ÿè´£æœåŠ¡å¥åº·ç›‘æ§
  ```

### 4.3 ä»£ç è·¯å¾„

- **æ–°å¢æ–‡ä»¶**ï¼š
  
  ```
    app/src/main/java/com/ovopark/cloudpos/dms/
    â”œâ”€â”€ domain/
    â”‚   â”œâ”€â”€ repository/IDMSRepository.kt
    â”‚   â””â”€â”€ usecase/
    â”‚       â”œâ”€â”€ DMSConnectionUseCase.kt
    â”‚       â”œâ”€â”€ SendHeartbeatUseCase.kt
    â”‚       â””â”€â”€ ProcessCommandUseCase.kt
    â”œâ”€â”€ data/
    â”‚   â”œâ”€â”€ repository/DMSRepository.kt
    â”‚   â”œâ”€â”€ manager/MqttConnectionManager.kt
    â”‚   â”œâ”€â”€ processor/CommandProcessor.kt
    â”‚   â””â”€â”€ provider/DeviceInfoProvider.kt
    â”œâ”€â”€ infrastructure/
    â”‚   â”œâ”€â”€ statemachine/DMSStateMachine.kt
    â”‚   â”œâ”€â”€ monitor/NetworkStateMonitor.kt
    â”‚   â”œâ”€â”€ reconnection/ReconnectionManager.kt
    â”‚   â”œâ”€â”€ exception/ExceptionHandler.kt
    â”‚   â””â”€â”€ watchdog/ServiceWatchdog.kt
    â””â”€â”€ service/DMSLifecycleService.kt
  ```
  
- **ä¿®æ”¹æ–‡ä»¶**ï¼š
  
  ```
    MyApplication.ktï¼ˆæ·»åŠ DMSæœåŠ¡å¯åŠ¨ï¼‰
    MainActivity.ktï¼ˆæ·»åŠ çŠ¶æ€è§‚å¯Ÿï¼‰
    di/AppModule.ktï¼ˆæ·»åŠ DMSæ¨¡å—ï¼‰
  ```

## 05.å…¼å®¹æ€§è®¾è®¡

### 5.1 è®¾å¤‡é€‚é…

- **å±å¹•å°ºå¯¸**ï¼šå°å±è®¾å¤‡æŠ˜å å¸ƒå±€æ–¹æ¡ˆ
- **ç³»ç»Ÿç‰ˆæœ¬**ï¼š

### 5.2 å†²çªæ£€æŸ¥

| ç°æœ‰åŠŸèƒ½ | å†²çªé£é™© | è§£å†³æ–¹æ¡ˆ |

| :------- | :----------- | :------- |

| NetworkMonitorService | å¯èƒ½é‡å¤ç›‘å¬ç½‘ç»œ | åˆå¹¶åˆ°ç»Ÿä¸€çš„ç½‘ç»œç›‘æ§æ¨¡å— |

| å‰å°é€šçŸ¥ | å¤šä¸ªé€šçŸ¥å†²çª | ä½¿ç”¨ç»Ÿä¸€çš„é€šçŸ¥ç®¡ç†å™¨ |

| WakeLock | å¯èƒ½é‡å¤æŒæœ‰ | ä½¿ç”¨å¼•ç”¨è®¡æ•°ç®¡ç† |

## 06.æµ‹è¯•æ–¹æ¡ˆ

### 6.1 æ ¸å¿ƒç”¨ä¾‹

- è¿æ¥æµ‹è¯•ï¼š
  - æ­£å¸¸è¿æ¥æµç¨‹æµ‹è¯•
  - ç½‘ç»œæ–­å¼€é‡è¿æµ‹è¯•
  - æœåŠ¡å™¨åˆ‡æ¢æµ‹è¯•
  - è®¤è¯å¤±è´¥é‡è¯•æµ‹è¯•

- å¿ƒè·³æµ‹è¯•ï¼š
  - å¿ƒè·³æ•°æ®æ ¼å¼éªŒè¯
  - å¿ƒè·³é—´éš”å‡†ç¡®æ€§æµ‹è¯•
  - å¿ƒè·³å¤±è´¥é‡è¿æµ‹è¯•

- æŒ‡ä»¤å¤„ç†æµ‹è¯•ï¼š
  - å¥åº·æ£€æŸ¥æŒ‡ä»¤æµ‹è¯•
  - é‡å¯æŒ‡ä»¤æµ‹è¯•ï¼ˆæ¨¡æ‹Ÿï¼‰
  - æ— æ•ˆæŒ‡ä»¤å¤„ç†æµ‹è¯•

### 6.2 æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | é¢„æœŸå€¼ | å®æµ‹å€¼ |

| :--------- | :----- | :----- |

| å†…å­˜å¢é‡ | <5MB | - |

| è¿æ¥å»ºç«‹æ—¶é—´ | <10s | - |

| å¿ƒè·³å»¶è¿Ÿ | <1s | - |

| é‡è¿æˆåŠŸç‡ | >95% | - |

| ç”µæ± æ¶ˆè€— | <2%/h | - |

## 07.å‘å¸ƒè®¡åˆ’

### 7.1 é˜¶æ®µå‘å¸ƒ

| é˜¶æ®µ | èŒƒå›´ | éªŒè¯é‡ç‚¹ | åŠŸèƒ½èŒƒå›´ |

| :---- | :------- | :------- | :------- |

| Alpha | å†…éƒ¨æµ‹è¯• | æ ¸å¿ƒè¿æ¥æµç¨‹ | åŸºç¡€MQTTè¿æ¥ + å¿ƒè·³ |

| Beta | 5å°è®¾å¤‡ | ç¨³å®šæ€§æµ‹è¯• | å®Œæ•´åŠŸèƒ½ + å¼‚å¸¸å¤„ç† |

| RC | 20å°è®¾å¤‡ | æ€§èƒ½éªŒè¯ | å…¨åŠŸèƒ½ + ä¼˜åŒ– |

| GA | å…¨é‡è®¾å¤‡ | ç”Ÿäº§ç›‘æ§ | æœ€ç»ˆç‰ˆæœ¬ |

### 7.2 å›æ»šæ–¹æ¡ˆ

- åŠŸèƒ½å¼€å…³ï¼šé€šè¿‡è¿œç¨‹é…ç½®æ§åˆ¶DMSåŠŸèƒ½å¼€å¯/å…³é—­

- é™çº§ç­–ç•¥ï¼šDMSè¿æ¥å¤±è´¥æ—¶ä¸å½±å“ä¸»è¦æ”¶é“¶åŠŸèƒ½

- ç´§æ€¥ä¿®å¤ï¼šå…³é”®é—®é¢˜æ”¯æŒçƒ­ä¿®å¤



## 08.æ–‡æ¡£è®°å½•

### 8.1 æŠ€æœ¯æ–‡æ¡£

- [æ¶æ„è®¾è®¡æ–‡æ¡£](https://xn--gzu811i/)
- [æ¥å£APIæ–‡æ¡£](https://xn--gzu811i/)

### 8.2 ç”¨æˆ·æ–‡æ¡£

- åŠŸèƒ½å¼•å¯¼é¡µè®¾è®¡
- é”™è¯¯ä»£ç å¯¹ç…§è¡¨

### 8.3 ç›‘æ§åŸ‹ç‚¹

```
// analytics_events.json
{
  "dms_connection_established": {
    "params": ["device_id", "connection_time", "network_type"]
  },
  "dms_connection_failed": {
    "params": ["device_id", "error_type", "retry_count"]
  },
  "dms_heartbeat_sent": {
    "params": ["device_id", "heartbeat_interval", "data_size"]
  },
  "dms_command_received": {
    "params": ["device_id", "command_type", "execution_result"]
  },
  "dms_reconnection_triggered": {
    "params": ["device_id", "failure_reason", "retry_strategy"]
  }
}
```

### 8.4 æ—¥å¿—ç­–ç•¥

```
*// æ—¥å¿—çº§åˆ«å’Œå†…å®¹å®šä¹‰*

object DMSLogTags {

  const val CONNECTION = "DMS_CONN"   *// è¿æ¥ç›¸å…³æ—¥å¿—*

  const val HEARTBEAT = "DMS_HEART"   *// å¿ƒè·³ç›¸å…³æ—¥å¿—*

  const val COMMAND = "DMS_CMD"     *// æŒ‡ä»¤å¤„ç†æ—¥å¿—*

  const val NETWORK = "DMS_NET"     *// ç½‘ç»œçŠ¶æ€æ—¥å¿—*

  const val STATE = "DMS_STATE"     *// çŠ¶æ€æœºæ—¥å¿—*

  const val ERROR = "DMS_ERROR"     *// é”™è¯¯å¤„ç†æ—¥å¿—*

}
```

## 9.æ€»ç»“

æœ¬æ–¹æ¡ˆé‡‡ç”¨çŠ¶æ€æœºé©±åŠ¨çš„å“åº”å¼MQTTæ¶æ„ï¼Œç›¸æ¯”ä¼ ç»Ÿçš„Service+Manageræ¨¡å¼ï¼Œåœ¨ä»¥ä¸‹æ–¹é¢æœ‰æ˜¾è‘—ä¼˜åŠ¿ï¼š

### âœ… æ¶æ„ä¼˜åŠ¿

1. èŒè´£æ¸…æ™°ï¼šæ¯ä¸ªç»„ä»¶åªå…³æ³¨è‡ªå·±çš„èŒè´£èŒƒå›´

1. çŠ¶æ€å¯æ§ï¼šçŠ¶æ€æœºè®©å¤æ‚çš„è¿æ¥æµç¨‹å˜å¾—å¯é¢„æµ‹

1. å“åº”å¼ï¼šä½¿ç”¨Flowæä¾›å®æ—¶çŠ¶æ€æ›´æ–°

1. å¯æµ‹è¯•ï¼šæ¯ä¸ªç»„ä»¶éƒ½å¯ä»¥ç‹¬ç«‹æµ‹è¯•

### âœ… åŠŸèƒ½å®Œå¤‡

1. åŒé˜¶æ®µè¿æ¥ï¼šé‡å®šå‘æœåŠ¡å™¨ â†’ çœŸå®DMSæœåŠ¡å™¨

1. æ™ºèƒ½é‡è¿ï¼šæŒ‡æ•°é€€é¿ç­–ç•¥ + ç½‘ç»œçŠ¶æ€æ„ŸçŸ¥

1. æŒ‡ä»¤å¤„ç†ï¼šæ”¯æŒé‡å¯ã€æ¢å¤å‡ºå‚ã€å¥åº·æ£€æŸ¥ç­‰

1. å¼‚å¸¸è‡ªæ„ˆï¼šå…¨é¢çš„å¼‚å¸¸å¤„ç†å’ŒæœåŠ¡ç›‘æ§

### âœ… ç”Ÿäº§å°±ç»ª

1. æ€§èƒ½ä¼˜åŒ–ï¼šå†…å­˜ç®¡ç†ã€ç”µæ± ä¼˜åŒ–

1. ç›‘æ§å®Œå¤‡ï¼šæ—¥å¿—ã€åŸ‹ç‚¹ã€æ€§èƒ½æŒ‡æ ‡

1. å¯è¿ç»´ï¼šè¿œç¨‹é…ç½®ã€é™çº§ç­–ç•¥ã€ç´§æ€¥ä¿®å¤

è¿™ä¸ªæ¶æ„è®¾è®¡ä¸ä»…è§£å†³äº†å½“å‰çš„DMSå¿ƒè·³éœ€æ±‚ï¼Œè¿˜ä¸ºæœªæ¥çš„åŠŸèƒ½æ‰©å±•æä¾›äº†åšå®çš„åŸºç¡€ã€‚é€šè¿‡çŠ¶æ€æœºçš„æ¸…æ™°å»ºæ¨¡å’Œç»„ä»¶åŒ–çš„è®¾è®¡ï¼Œæ•´ä¸ªç³»ç»Ÿå˜å¾—å¯ç»´æŠ¤ã€å¯æ‰©å±•ã€å¯æµ‹è¯•ã€‚
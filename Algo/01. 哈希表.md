[toc]



## 02.字母异位词分组

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, String> map = new HashMap<>();
        for (String str : strs) {
            char ch = str.toChar();
            Arrays.sort(ch);
            String temp = ch.toString();

            map.put(temp, str);
        }
        return map.getAllValues;
    }
}
```

### **问题1：`char ch = str.toChar();`**

- **问题：** `String` 类型没有 `toChar()` 方法，而是需要将字符串转换为字符数组。
- **修正：** 使用 `str.toCharArray()` 将字符串转换为字符数组。

**修改：**

```
java


复制代码
char[] ch = str.toCharArray();
```

------

### **问题2：`String temp = ch.toString();`**

- **问题：** `ch.toString()` 并不会返回字符数组的内容，而是返回字符数组对象的地址。你需要使用 `String.valueOf()` 或 `new String(ch)` 将字符数组转化为字符串。
- **修正：** 使用 `new String(ch)` 将排序后的字符数组转换为字符串。

**修改：**

```
java


复制代码
String temp = new String(ch);
```

------

### **问题3：`map.put(temp, str);`**

- **问题：** 你的代码将 `temp` 作为键，`str` 作为值，但当不同的字符串对应同一个键（即是字母异位词时），会覆盖之前的值。
- **修正：** 使用 `List<String>` 存储值，并在值已经存在时将新的字符串添加到列表中。

### **问题4：`return map.getAllValues;`**

- **问题：** `HashMap` 没有 `getAllValues` 方法，你可能想返回 `map` 的所有值集合。
- **修正：** 使用 `map.values()` 返回 `Collection<List<String>>`，然后将其转换为 `List<List<String>>`。





怎么理解：ch.toString() 并不会返回字符数组的内容，而是返回字符数组对象的地址。	

### **原因分析**

#### **1. `toString()` 的行为来源于 `Object` 类**

- 在 Java 中，所有类都继承自 

  ```
  Object
  ```

   类，而 

  ```
  Object
  ```

   类的 

  ```
  toString()
  ```

   方法默认实现如下：

  ```
  java复制代码public String toString() {
      return getClass().getName() + "@" + Integer.toHexString(hashCode());
  }
  ```

- 对于数组来说，

  ```
  toString()
  ```

   的行为没有被重写，因此数组调用 

  ```
  toString()
  ```

   返回的是：

  - 数组的类型名（如 `[C` 表示字符数组类型 `char[]`）。
  - `@` 后跟数组对象的哈希值（默认用 16 进制表示）。

- 这并不是数组内容的字符串形式，而是数组对象的描述。

------

#### **2. 示例代码**

```
java复制代码public class Main {
    public static void main(String[] args) {
        char[] ch = {'a', 'b', 'c'};
        
        // 调用 toString()
        System.out.println(ch.toString());
        
        // 正确的字符数组内容表示
        System.out.println(new String(ch));
    }
}
```

**输出：**

```
graphql复制代码[C@15db9742
abc
```

- `[C` 表示字符数组的类型（`char[]`）。
- `@15db9742` 是数组对象的哈希码，默认以 16 进制形式显示。



 换一种方式，这个太不好记了// 如果键不存在，初始化一个列表    map.putIfAbsent(temp, new ArrayList<>());

### **替代写法：使用 `containsKey()` 检查**

```
java复制代码if (!map.containsKey(temp)) {
    map.put(temp, new ArrayList<>());
}
map.get(temp).add(str);
```

------

### **逻辑拆解**

1. **检查键是否存在：**
   `if (!map.containsKey(temp))`
   如果键 `temp` 不存在，说明需要为这个键初始化一个新的列表。
2. **初始化新列表并添加到 `Map` 中：**
   `map.put(temp, new ArrayList<>());`
   为键 `temp` 创建一个新的空列表，并存入 `Map`。
3. **获取键对应的列表并添加字符串：**
   `map.get(temp).add(str);`
   从 `Map` 中获取键对应的列表，将当前字符串 `str` 添加到其中。



怎么理解：return new ArrayList<>(map.values());



这句代码：

```
java


复制代码
return new ArrayList<>(map.values());
```

可以分解理解为以下几个部分：

------

### **1. `map.values()` 是什么？**

- `map.values()` 方法：
  - 返回 `Map` 中所有值的集合（`Collection<V>` 类型）。
  - 具体来说，对于 `Map<String, List<String>>`，`map.values()` 返回一个包含所有 `List<String>` 的 `Collection`。
  - 注意：这个集合视图与原始 `Map` 相关联，修改此视图会影响原始 `Map`。

------

### **2. 为什么需要 `new ArrayList<>(...)`？**

- `map.values()` 返回的是 `Collection`，但题目需要的是 `List<List<String>>`。

- ```
  new ArrayList<>(...)
  ```

   的作用是：

  1. 将 `Collection` 转换为 `ArrayList`：
     - 直接创建一个新的 `ArrayList`，并用 `Collection` 的所有元素初始化这个列表。
     - 这样可以确保返回的结果是一个明确的 `List` 类型，而非仅仅是 `Collection`。
  2. 创建一个副本：
     - 返回的新 `ArrayList` 与 `map.values()` 分离，修改返回的列表不会影响原始的 `Map`，提高了安全性。

------

### **3. 代码含义总结**

这句代码将 `Map` 的所有值集合转化为一个新的列表返回。最终返回的类型是 `List<List<String>>`。
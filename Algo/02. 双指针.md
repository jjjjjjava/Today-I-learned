[toc]



## 01. 移动零

1.1 

[283. 移动零](https://leetcode.cn/problems/move-zeroes/)

已解答

简单



相关标签

相关企业



提示



给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

 

**提示**:

- `1 <= nums.length <= 104`
- `-231 <= nums[i] <= 231 - 1`

 

**进阶：**你能尽量减少完成的操作次数吗？

1.2



```
class Solution {
    private void helper(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }
    public void moveZeroes(int[] nums) {
        int l = 0, r = 0;
        for (; l < nums.length; l++) {
            if (nums[l] == 0) {
                for (r = l + 1; r < nums.length; r++) {
                    if (nums[r] != 0) {
                        helper(nums, l, r);
                        break;
                    }
                }
            }
        }
    }
}
```

方法一：双指针
思路及解法

使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。

右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

注意到以下性质：

左指针左边均为非零数；

右指针左边直到左指针处均为零。

因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。

作者：力扣官方题解
链接：https://leetcode.cn/problems/move-zeroes/solutions/489622/yi-dong-ling-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

比较你的算法和官方题解的差异，可以从以下几个方面分析：

### 1. **算法思想**

- 你的算法

  ：

  - 使用两个指针 `l` 和 `r`。
  - 外层循环从头到尾遍历数组，找到为 `0` 的位置（`l` 指针）。
  - 内层循环从 `l+1` 开始，寻找第一个非 `0` 的元素（`r` 指针），然后进行交换。
  - 逐一移动每个 `0`，效率偏低。

- 官方题解

  ：

  - 使用双指针法，`left` 指针始终指向数组中非 `0` 元素的插入位置。
  - `right` 指针用于遍历整个数组。
  - 每当 `nums[right] != 0` 时，直接将其与 `nums[left]` 交换，同时 `left` 移动到下一个插入位置。
  - 通过一次遍历完成所有非 `0` 元素的移动，效率更高。

### 2. **时间复杂度**

- 你的算法

  ：

  - 外层循环遍历每个元素，内层循环在最坏情况下可能遍历剩余的所有元素。
  - 时间复杂度为 **O(n²)**（最坏情况下数组中大部分元素为 `0`）。

- 官方题解

  ：

  - 单次遍历数组，每个元素只被访问一次。
  - 时间复杂度为 **O(n)**。

### 3. **空间复杂度**

- 两种算法的空间复杂度都是 **O(1)**，因为只使用了常数额外空间。

### 4. **代码可读性**

- 你的算法

  ：

  - 内外嵌套的两层循环逻辑较复杂。
  - 内层的 `break` 控制需要理解为找到第一个非 `0` 元素后立即跳出，逻辑不直观。

- 官方题解

  ：

  - 单一循环逻辑清晰，直观地通过 `left` 指针维护非 `0` 的插入位置。
  - 利用了更简洁的双指针法，代码更容易理解和维护。

### 5. **运行效率**

- 对于大部分情况下（如数组中 `0` 较少），两种算法表现可能接近。
- 在极端情况下（如数组中大部分元素为 `0`），你的算法效率会显著下降，而官方题解的性能更稳定。

------

### **优化建议**

你可以将你的算法改写为官方题解的方式，直接用双指针实现单次遍历，这样既能提升效率，也能提高代码的简洁性。例如：

```
java复制代码class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0;
        for (int right = 0; right < nums.length; right++) {
            if (nums[right] != 0) {
                // 交换非零元素到左侧
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
                left++;
            }
        }
    }
}
```

这种写法和官方题解完全一致，逻辑清晰、效率更高。
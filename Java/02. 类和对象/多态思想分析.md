[toc]

## 01.快速了解多态

###  什么是多态

**一句话概括**：**多态允许子类替换父类，并在运行时根据子类的类型调用具体实现**。

多态的关键在于**动态绑定**，即在程序运行时根据实际的对象类型来调用对应的方法。编译器在编译时并不知道引用变量所指向的具体类型，也无法确定会调用哪个方法；而在运行时，JVM 会根据引用变量指向的具体对象，选择调用相应类中的方法。

因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

## 02.多态如何实现

### 实现条件

- Java实现多态有三个必要条件：继承、重写、向上转型。
  - 继承：在多态中必须存在有继承关系的子类和父类。
  - 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
  - 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。



### 实现方式

### 1. **基于继承的多态**

**定义**：基于继承的多态是指通过**类的继承**来实现多态性。子类继承父类，重写父类的方法，然后在运行时根据对象的实际类型调用子类的方法，而不是父类的方法。

#### **关键点**：

- 通过继承，子类可以拥有父类的所有属性和方法。
- 子类可以**重写（Override）**父类中的方法，以提供自己独特的实现。
- 父类的引用可以指向子类的对象，运行时根据实际对象的类型调用相应的重写方法。

#### **示例**：

```
java复制代码class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();  // 父类引用指向子类对象
        myAnimal.sound();  // 输出：Dog barks

        myAnimal = new Cat();  // 父类引用指向另一个子类对象
        myAnimal.sound();  // 输出：Cat meows
    }
}
```



### 2. **基于接口的多态**

**定义**：基于接口的多态是通过**实现接口**来实现的。不同的类可以实现同一个接口，并提供接口方法的不同实现。接口定义了一组方法，而具体的实现由类来提供。在运行时，接口的引用指向不同的实现类对象，从而实现多态。

#### **关键点**：

- 接口定义了一组方法，但没有方法的具体实现。
- 不同的类可以实现同一个接口，并提供接口方法的具体实现。
- 接口的引用可以指向任何实现该接口的对象，运行时调用的是具体实现类的方法。

#### **示例**：

```
java复制代码interface Animal {
    void sound();
}

class Dog implements Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

class Cat implements Animal {
    @Override
    public void sound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();  // 接口引用指向 Dog 实现类
        myAnimal.sound();  // 输出：Dog barks

        myAnimal = new Cat();  // 接口引用指向 Cat 实现类
        myAnimal.sound();  // 输出：Cat meows
    }
}
```



## 03. 多态底层原理

虚拟方法调用（Virtual Method Invocation）：在 Java 中，所有的非私有、非静态和非 final 方法都是被隐式地指定为虚拟方法。虚拟方法调用是在运行时根据实际对象的类型来确定要调用的方法的机制。当通过父类类型的引用变量调用被子类重写的方法时，虚拟机会根据实际对象的类型来确定要调用的方法版本，而不是根据引用变量的声明类型。

例如：

```
java复制代码Animal myAnimal = new Dog();  // Animal 是引用类型，Dog 是实际类型
myAnimal.sound();  // 运行时调用 Dog 的 sound() 方法，而不是 Animal 的
```

虽然在编译时 `myAnimal` 的类型是 `Animal`，但是在运行时，JVM 通过动态绑定机制，调用 `Dog` 类的 `sound()` 方法，而不是 `Animal` 的 `sound()` 方法。

### 2. **方法表（vtable）在动态绑定中的作用**

方法表（vtable，虚函数表）是一个数据结构，用于存储类中每个方法的实际地址。每个类都会有一张方法表，记录了类中的方法以及它们在内存中的位置。方法表在运行时用于快速查找某个对象的实际方法实现。子类继承父类时，会拥有父类的方法表，并且可以在自己的方法表中覆盖父类的方法。

- **父类方法表**：父类中的所有方法都在方法表中有索引，对应的值是这些方法的实际内存地址。
- **子类方法表**：子类继承了父类的方法表，但如果子类重写了父类的方法，那么该方法在方法表中的条目会被替换为子类的实现。

### 3. **动态绑定的工作原理**

在 Java 中，当调用某个对象的方法时，JVM 会根据对象的实际类型进行动态绑定。这个过程可以概括为以下步骤：

1. **访问栈上的调用者对象**：当程序执行方法调用时，JVM 会从栈中找到方法调用者对象（即这个方法是在哪个对象上调用的）。
2. **读取调用者的动态类型**：JVM 不仅关注引用类型（编译时的类型），还会检查该对象的实际动态类型（运行时类型），以此来判断它实际是哪一个类的实例。
3. **获取该类型的**`方法表`**（vtable）**：每个类在运行时都有一张方法表，JVM 会根据对象的动态类型找到对应类的 vtable。
4. **从方法表中读取对应的目标方法**：方法表中每个方法都有一个索引值，JVM 会根据编译时提供的方法索引来找到方法表中对应的方法的内存地址。
5. **执行方法**：最终，JVM 通过找到的内存地址来执行实际的方法实现。


[toc]



## 01. 公平锁

- 公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁（并不是绝对的，大体上是这种顺序），这种就是公平锁。

公平锁可以保证线程**按照时间的先后顺序**执行，避免饥饿现象的产生。但公平锁的效率比较低，因为要实现顺序执行，需要维护一个有序队列。



## 02. 悲观锁/乐观锁

这涉及到读写操作的频率。有读无写是不会产生线程安全性问题的，如果全是写操作，那么大概率发生，很少写操作，那么小概率发生。

悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。

- 悲观锁在Java中的使用，就是利用各种锁。
- 乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

### 2.1 乐观锁

- 一句话概括
  - 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。因此在采取写操作时，不会加锁，而是**会采用尝试更新，不断重新的方式更新数据**。
- 具体工作原理
  - 乐观锁一般通过**版本号**或**时间戳**来实现。
  - 当线程读取数据时，它不会锁住资源，而是记录下数据的版本号。
  - 当线程要修改数据时，它会检查当前数据的版本号是否与读取时一致。如果一致，则说明没有其他线程修改过该数据，线程可以安全地更新数据；如果版本号不同，则说明数据已经被其他线程修改过，当前操作会失败，通常需要重试或报错。
- 乐观锁有哪些
  - CAS



### 2.2 悲观锁

- 一句话概括
  - 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
- 悲观锁有哪些
  - synchronized，Lock锁等





### 2.3 CAS操作实现乐观锁

Compare And Swap，比较交换，底层基于原子命令。

**CAS 操作的三个操作数**：

- **内存位置**（`V`）：需要操作的变量地址（共享变量的内存地址）。
- **预期值**（`E`）：当前线程期望该变量的值，即线程读取到的旧值。
- **新值**（`N`）：需要写入的新值。

更新过程：比较-更新-失败处理。

- 如果 `V` 中的值等于 `E`，那么将 `N` 写入 `V`，表示更新成功。
- 如果 `V` 中的值不等于 `E`，说明已经被其他线程修改过，此时更新失败。

这个操作是**原子性**的，也就是说，CAS 能够保证在并发环境下只有一个线程能成功更新变量，而其他线程会失败并重试。



## 03. 可重入锁

**可重入锁**允许同一个线程在持有锁的情况下，**再次获取该锁而不会发生阻塞或死锁**。

**举个例子加深理解**

来看一个具体的代码示例，展示 `synchronized` 如何作为一个可重入锁工作：

```java
public class ReentrantLockExample {

    public synchronized void setA() throws InterruptedException {
        System.out.println("Executing setA()");
        Thread.sleep(1000);  // 模拟操作耗时
        setB();  // 调用setB
    }

    public synchronized void setB() throws InterruptedException {
        System.out.println("Executing setB()");
        Thread.sleep(1000);  // 模拟操作耗时
    }

    public static void main(String[] args) throws InterruptedException {
        ReentrantLockExample example = new ReentrantLockExample();
        example.setA();  // 主线程调用 setA 方法
    }
}
```

**代码分析**：

- **`setA()` 方法**是被 `synchronized` 修饰的，当线程调用 `setA()` 时，它会获取对象级别的锁。
- 在 `setA()` 方法内部，调用了 `setB()`，而 `setB()` 也是 `synchronized` 的，这意味着线程必须再次获取同一个对象的锁。
- 由于 `synchronized` 是**可重入的**，同一个线程可以再次获取已经持有的锁，所以程序能够顺利执行，而不会发生死锁。

**输出**：

```scss
Executing setA()
Executing setB()
```

### 3.1 **为什么可重入锁能避免死锁？**

可重入锁的好处之一是**避免死锁**。假设 `synchronized` 不是可重入的，那么当 `setA()` 方法执行到 `setB()` 时，当前线程试图再次获取已经持有的锁就会被阻塞，因为这个锁已经被当前线程持有而没有释放。如果锁不能重入，线程会被自己锁住，从而导致死锁。





## 04. 共享锁和独占锁

在并发编程中，锁可以分为**共享锁（Shared Lock）和 独占锁（Exclusive Lock）**。

共享锁允许多个线程同时获取该锁，从而允许这些线程并发访问共享资源，通常用于**读操作**，因为读操作不会破坏数据的一致性。

另一方面，写操作则需要独占锁，一次只能被一个线程持有，因为写操作可能会破坏数据的一致性。



## 05. 互斥锁/读写锁

**互斥锁**，也叫做**独占锁**，是指在同一时刻**只有一个线程**能够获取锁并访问共享资源，其他线程必须等待锁被释放才能继续操作。

**读写锁**是一种同时允许多个线程并发读取资源，但只允许一个线程写入资源的锁机制，分为读锁和写锁。



## 06. 分段锁

- 一句话概括
  - 分段锁其实是一种锁的设计，并不是具体的一种锁，
- 举个例子
  - 比如：ConcurrentHashMap，分为多个Segment ，每个Segment就是一个HashMap。每个段拥有自己的段锁。
- 分段锁的设计目的
  - 主要是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。



## 07. 偏向锁/轻量级锁/重量级锁

- 这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
- **偏向锁**不是锁，是一种**偏向于某个线程**的优化。假设一段同步代码始终被同一个线程执行，那么每次进入同步块时，这个线程无需进行复杂的加锁操作，直接将锁**偏向**于该线程，降低锁的获取成本。
- 轻量级锁自旋锁，当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
- 重量级锁：相当于内核中的Mutex互斥锁，当线程无法获取锁时会进入**阻塞状态**，直到持有锁的线程释放锁后，阻塞的线程才会被唤醒。如果轻量级锁下的线程竞争过于激烈，或者线程自旋了一定次数之后还无法获得锁，锁会**膨胀为重量级锁**。



## 08. 可中断锁

如果我再等待锁过程中需要去处理其它事情，那我需要可中断锁，它可以响应线程中断，允许线程在等待锁的过程中被中断，从而避免长时间等待或阻塞。

- 有哪些中断锁
  - 在Java中，**synchronized就不是可中断锁，而Lock是可中断锁**。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。`lockInterruptibly()`的用法体现了Lock的可中断性。



## 09.自旋锁

- 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。



## 其他介绍

### 01.关于我的博客

- github：https://github.com/jjjjjjava
- 简书：http://www.jianshu.com/u/92a2412be53e
- csdn：http://my.csdn.net/qq_35829566
- 邮箱：[934137388@qq.com](mailto:934137388@qq.com)
- 掘金：https://juejin.im/user/499639464759898




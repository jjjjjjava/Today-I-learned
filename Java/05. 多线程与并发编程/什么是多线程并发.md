[toc]

## 01.线程安全

什么是线程安全？

在多线程环境下，代码的执行结果与单线程执行时的结果一致，并且变量的状态也是符合预期的



下面是一个线程不安全的例子，我们期望的结果是count自增2次1000，最终为2000。

实际会低于2000.

```java
class Counter {
    private int count = 0;

    public void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        // 创建两个线程，每个线程对 counter 进行 1000 次自增操作
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        t1.start();
        t2.start();

        // 等待两个线程执行完毕
        t1.join();
        t2.join();

        // 打印最终结果
        System.out.println("Final count: " + counter.getCount());
    }
}

```



## 02.多线程三要素

那么请问：多线程安全的需要满足哪些要素？

要满足如下三要素，分别是：原子性，可见性，有序性

#### 2.1 如何理解原子性

- 如何理解原子性
  - 即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。
- 举一个例子
  - 关于原子性，一个非常经典的例子就是银行转账问题：比如A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。

#### 2.2 如何理解可见性

- 如何理解可见性
  - 当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。
- 举一个例子
  - CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，**修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存**（实际上写回主内存的时间不可预期）。**此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。**这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。

#### 2.3 如何理解有序性

- 如何理解有序性

  - 顺序性指的是，程序执行的顺序按照代码的先后顺序执行。

- 举一个例子

  - 考量一个语句 instance = new Singleton();
  - 这条语句实际上包含了三个操作：1.分配对象的内存空间；2.初始化对象；3.设置instance指向刚分配的内存地址。但由于存在重排序的问题，可能有以下的执行顺序：

  ![image-20241016214747414](./../_pic_/image-20241016214747414.png)

  - 如果2和3进行了重排序的话，线程B进行判断if(instance==null)时就会为true，而实际上这个instance并没有初始化成功，显而易见对线程B来说之后的操作就会是错得，它会访问一片未被初始化的空间进而产生错误。而**用volatile修饰**的话就可以禁止2和3操作重排序，从而避免这种情况。这就是指令重排造成的后果，以及有序性的作用

- 由这个例子我们可以发现，如果不存在线程B，那么即使进行指令重排，也不影响A线程对对象的正确访问。所以单线程不存在有序性问题。所以锁能解决有序性问题的本质不是他们可以禁止指令重排，而是其单线程执行临界区中代码块，此时不存在有序性问题。

## 03.处理多线程并发

处理多线程并发就要满足上述的三要素。

- 原子性（Atomicity）：单个或多个操作是要么全部执行，要么都不执行
  - Lock：保证同时只有一个线程能拿到锁，并执行申请锁和释放锁的代码
  - synchronized：对线程加独占锁，被它修饰的类/方法/变量只允许一个线程访问
- 可见性（Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改
  - volatile：保证新值能立即同步到主内存，且每次使用前立即从主内存刷新；
  - synchronized：在释放锁之前会将工作内存新值更新到主存中
- 有序性（Ordering）：程序代码按照指令顺序执行
  - volatile： 本身就包含了禁止指令重排序的语义
  - synchronized：保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入



## 04.Java中相关概念

##### 4.3.1 同步VS异步

- 同步和异步通常用来形容一次方法调用。
  - 同步方法调用一开始，调用者必须等待被调用的方法结束后，调用者后面的代码才能执行。同步操作意味着线程阻塞等待锁。 
  - 而异步调用，指的是，调用者不用管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。
- 举个例子
  - 比如，在超时购物，如果一件物品没了，你得等仓库人员跟你调货，直到仓库人员跟你把货物送过来，你才能继续去收银台付款，这就类似同步调用。
  - 而异步调用了，就像网购，你在网上付款下单后，什么事就不用管了，该干嘛就干嘛去了，当货物到达后你收到通知去取就好。

##### 4.3.2 并发与并行

- 并发和并行是十分容易混淆的概念。
  - 并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进行”。
- 实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。

##### 4.3.3 阻塞和非阻塞

- 阻塞和非阻塞通常用来形容多线程间的相互影响，比如一个线程占有了临界区资源，那么其他线程需要这个资源就必须进行等待该资源的释放，会导致等待的线程挂起，这种情况就是阻塞，而非阻塞就恰好相反，它强调没有一个线程可以阻塞其他线程，所有的线程都会尝试地往前运行。

##### 4.3.4 临界区

- 临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。
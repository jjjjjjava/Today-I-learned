[toc]

## 01.先思考三个问题

- 在了解回收机制之前，必须要了解内存

  - 程序计数器、虚拟机栈、本地方法栈随线程而生，也随线程而灭；栈帧随着方法的开始而入栈，随着方法的结束而出栈。这几个区域的内存分配和回收都具有确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收。
  - 对于 Java 堆和方法区，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的正是这部分内存。

- 先思考三个问题

  - JVM是怎么分配内存的
  - 识别哪些内存是垃圾需要回收
  - 最后才是用什么方式回收

- 栈与堆

  栈是运行时，堆是超越线程生命周期

## 02.什么是垃圾回收

- 什么是垃圾回收？
  - 垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。
- 怎么理解？
  - 引用：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。（引用都有哪些？对垃圾回收又有什么影响？）
  - 垃圾：无任何对象引用的对象，对象占据内存空间，但是如果程序中没有任何引用持有该对象的地址，那么虽然它有内存空间，但是我们无法正常访问到它，这就是垃圾。（怎么通过算法找到这些对象呢？）。
  - 回收：清理“垃圾”占用的内存空间而非对象本身（怎么通过算法实现回收呢？）。
  - 发生地点：一般发生在堆内存中，因为大部分的对象都储存在堆内存中（堆内存为了配合垃圾回收有什么不同区域划分，各区域有什么不同？）。
  - 发生时间：程序空闲时间不定时回收（回收的执行机制是什么？是否可以通过显示调用函数的方式来确定的进行回收过程？）

## 03.理解JVM分配内存

我们要知道JVM怎么分配内存的，在哪分配，之后我们才知道应该在哪回收，怎么回收。

### 3.1 JVM内存池

**传统的动态内存分配**：如果 JVM 在每次 `new` 操作时都直接请求操作系统分配内存，操作系统就需要进行一次内存分配的系统调用，而系统调用涉及 CPU 保护模式的切换、内存分配管理等操作，开销较大。

**内存池机制**：JVM 启动时通过一次性请求一大块内存，减少了之后每次对象创建时的系统调用。这块内存池由 JVM 自行管理，当有新的对象请求分配内存时，JVM 会直接从这块内存中分配空间，而不需要通过操作系统。这就大大减少了内存分配的系统调用，**降低了内存分配的时间开销**。

### 3.2 静态内存和动态内存

Java一般内存申请有两种：

- 静态内存和动态内存。
- 很容易理解，编译时就能够确定的内存就是静态内存，即内存是固定的，系统一次性分配，比如int类型变量，int a = 10，编译时已经确定了其内存大小（4 字节）；
- 动态内存分配就是在程序执行时才知道要分配的存储空间大小，比如java对象的内存空间，如：`new int[size]`，其中 `size` 可以由用户输入决定或是`new String(input)` 时，Java 会在**堆内存**中分配一块空间，大小取决于 `input` 的长度（每个字符在 Java 中占用 2 字节）。

### 3.3 JVM内存分配与回收

- JDK1.8之前的堆内存示意图：
  - ![image-20241025203717243](./../_pic_/image-20241025203717243.png)
  - 从上图可以看出堆内存的分为新生代、老年代和永久代。新生代又被进一步分为：Eden 区＋Survior1 区＋Survior2 区。
  - 值得注意的是，在JDK1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。
- 分代回收算法
  - 目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
  - 大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。
- Minor Gc和Full GC 有什么不同呢？
  - **新生代GC（Minor GC）**:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。
  - **老年代GC（Major GC/Full GC）**:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。

## 04.识别哪些内存是垃圾

### 4.1 堆内存和方法区内存中的垃圾

1. **堆内存垃圾**：堆内存中的垃圾就是不可达的对象。什么是不可达，就是它本身还在那个分配的内存区域，但是，我没有引用持有它的地址，因此访问不到它，这就是不可达。还有一种特殊的不可达，A对象内部有B对象的引用，B对象内部有A对象的引用，但是A对象的地址丢失，B对象的地址丢失，此时虽然他们彼此持有，但是外部无法访问到他们两，他们形成了一个孤立的环。这是彼此引用不可达。

   举例：

   ```java
   class A {
       B b;
       void linkToB(B b) {
           this.b = b;
       }
   }
   
   class B {
       A a;
       void linkToA(A a) {
           this.a = a;
       }
   }
   
   public class Main {
       public static void main(String[] args) {
           A a = new A();
           B b = new B();
   
           a.linkToB(b);  // A对象持有B对象的引用
           b.linkToA(a);  // B对象持有A对象的引用
   
           a = null;  // 断开外部对A对象的引用
           b = null;  // 断开外部对B对象的引用
       }
   }
   ```

   

2. **方法区回收**：方法区的回收主要包括废弃常量（不再引用的常量）和无用的类（所有实例和类加载器被回收，并且类本身没有被引用）。

3. **回收频率**：堆内存中的垃圾回收更频繁，而方法区的垃圾回收相对较少，因为方法区中的内容生命周期较长。

### 4.2 局部变量和垃圾回收的关系？

局部变量表存储在每个方法的栈帧中，方法的执行过程中，**局部变量会作为 GC 的根节点**。被局部变量直接或间接引用的对象不会被回收，因为 GC 会认为它们仍在被使用。方法执行结束时，局部变量表对应的栈帧被销毁，这时局部变量失效，其引用的对象也就失去了根节点的保护，可以被回收。

### 05.用什么方式回收

#### 5.1 设置对象null

当一个对象的引用被置为 `null` 时，它与任何可达对象的引用链就被断开了，意味着该对象变为**不可达对象**，成为了 GC 的候选对象。

- 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？
  - 不会，垃圾回收是周期性地运行的，在下一个垃圾回收周期中，这个对象将是可被回收的。
  - 也就是说当一个对象的引用变为null时，并不会被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。

#### 5.2 包一个软引用或者弱引用

软引用允许垃圾回收器在内存不足的情况下回收引用的对象。

弱引用允许垃圾回收器在启动垃圾回收周期时回收引用的对象。

## 06.垃圾回收相关函数

## 08.GC回收原理分析



## 01.检测垃圾算法有哪些

- 垃圾收集器一般必须完成两件事：
  - 检测出垃圾；回收垃圾。
- 怎么检测出垃圾？
  - 一般有以下几种方法：引用计数法，可达性分析算法。注意有时候通常将可达性分析算法称为根搜索算法。
- 怎么去回收垃圾？
  - 对垃圾进行标记，然后使用垃圾回收算法对不可用的对象进行回收。

## 02.引用计数法分析

### 2.1 什么是引用计数法

给一个对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1。

### 2.2 引用计数的优缺点

- 引用计数的优点：
  - 垃圾收集器可以很快地执行，当一个对象的引用数为0时就可以回收这个对象，垃圾收集交织在程序的正常执行过程中，不用长时间中断程序的正常执行。
- 引用计数的缺点：
  - 1.每次引用计数的增加和减少会带来额外的开销；2.无法检测出循环引用，也就是孤立的引用环。
- 总结一下：
  - 难以检测出对象之间的循环引用。同时，引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。

[toc]

## 启动流程初步介绍

启动流程如下图：

![img](./../_pic_/16d63d17a01415f4tplv-t2oaga2asx-jj-mark3024000q75.webp)

纵观整个 Android 体系结构，底层内核空间以 Linux Kernel 为核心，上层用户空间以 C++/Java 组成的 Framework 层组成，通过系统调用来连接用户空间和内核空间。而用户空间又分为 Native 世界和 Java 世界，通过 JNI 技术进行连接。



### 系统启动

当电源按下时引导芯片代码会从预定义的地方（固化在ROM）开始执行，加载引导程序BootLoader到RAM，然后执行该引导程序。

### 引导程序BootLoader

它是Android操作系统开始运行前的一个小程序，主要将操作系统OS拉起来并进行。

### Linux内核启动

当内核启动时，会启动swapper进程(pid = 0)和kthreadd进程(pid = 2)：

- swapper进程：又称为idle进程，系统初始化过程Kernel由无到有开创的**第一个进程**, 用于初始化进程管理、内存管理，加载Binder Driver、Display、Camera Driver等相关工作。
- kthreadd进程：Linux系统的内核进程，**是所有内核进程的鼻祖**，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。

### Framework及应用程序启动

当内核完成系统设置时，它首先在系统中寻找init.rc文件，并启动init进程。init进程是一个由内核启动的**第一个用户级进程**，它的进程号是1，父进程id号是0。

init进程是所有用户空间的鼻祖, 它会启动servicemanager(binder服务管家，其功能为查询和注册服务), Zygote进程(Java进程的鼻祖). 

`Zygote` 创建的第一个进程就是 `System Server`，`System Server` 负责管理和启动整个 Java Framework 层。创建完 `System Server` 之后，`Zygote` 就会完全进入受精卵的角色，等待进行无性繁殖，创建应用进程。所有的应用进程都是由 `Zygote` 进程 fork 而来的，称之为 Java 世界的女娲也不足为过。





## Zygote进程

### 概述

Zygote通过`init`进程启动，并创建Java虚拟机（JVM），然后负责创建系统的其他进程，例如`system_server`，以及后续的应用程序进程。

**关键点**：Zygote的启动过程可以分为两个部分：

1. **启动并初始化Java虚拟机**。
2. **等待请求，创建新的进程（包括应用进程和系统服务进程）**。

### 流程概览

解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；

最终调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；此时完成了Java环境的准备。

通过JNI方式调用ZygoteInit.main()方法，第一次进入Java世界；

registerServerSocketFromEnv()方法建立socket通道，zygote作为通信的服务端，用于响应客户端请求；

preload()预加载通用类、相关资源，共享库等，用于提高app启动效率；

接下来再通过startSystemServer()，fork出system_server进程，也是上层framework的运行载体；

zygote调用runSelectLoop()方法等待，当接收到创建新进程请求时唤醒并执行相应工作。



### 代码流程

Zygote的启动流程涉及多个关键步骤，具体如下：

#### **1. `AppRuntime.start` 方法**

Zygote进程的启动点是 `app_main.cpp` 文件中的 `main()` 方法。

```cpp
int main(int argc, char* const argv[])
{
    AppRuntime runtime;
    runtime.start(...);
}
```

这里的`AppRuntime`类负责启动虚拟机，并加载Java层的`ZygoteInit`类。

#### **2. `AndroidRuntime.start()`**

在`main()`函数中，`AppRuntime`调用`AndroidRuntime.start()`，这将初始化Java虚拟机。

```cpp
void AndroidRuntime::start(const char* className, ...)
{
    startVm();
    startReg();
}
```

- **`startVm()`**：启动Java虚拟机（ART或DVM）。
- **`startReg()`**：注册JNI方法，确保Java和Native层能够互相调用。

#### **3. 进入Java世界：`ZygoteInit.main()`**

通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；

```java
public static void main(String argv[]) {
    registerServerSocketFromEnv();
    preload();
    forkSystemServer();
    runSelectLoop();
}
```

- **`registerServerSocketFromEnv()`**：创建一个ServerSocket，用于接收来自其他服务（如`ActivityManagerService`）的进程创建请求。
- **`preload()`**：预加载通用类、相关资源，共享库等，用于提高app启动效率；
- **`forkSystemServer()`**：创建并启动`system_server`进程，其是上层Java framework的运行载体；
- **`runSelectLoop()`**：进入一个无限循环，当接收到创建新进程请求时唤醒并执行相应工作。



## System_Server进程

 `system_server` 进程是 `Zygote` 进程 fork 出的第一个进程，它负责管理和启动整个 Framework 层。

### **Zygote创建SystemServer进程**

在Zygote的启动过程中，`forkSystemServer()`方法创建了`SystemServer`进程，并通过JNI调用进入Java层，执行`SystemServer`的`main()`方法。

### **SystemServer的启动流程**

它首先创建自身的实例并调用`run()`方法。在`run()`方法中，`SystemServer`执行一系列的初始化操作，并启动系统的核心服务。

#### 1. **`main()`方法**

```java
public static void main(String[] args) {
    new SystemServer().run();
}
```

#### 2. **`run()`方法**

`run()`方法是`SystemServer`的核心，它负责初始化系统的环境设置，创建和启动系统服务，最后进入事件循环处理消息。

```java
private void run() {
    try {
        // 设置系统时钟和时区等基本参数
        if (System.currentTimeMillis() < EARLIEST_SUPPORTED_TIME) {
            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);
        }

        String timezoneProperty = SystemProperties.get("persist.sys.timezone");
        if (timezoneProperty == null || timezoneProperty.isEmpty()) {
            SystemProperties.set("persist.sys.timezone", "GMT");
        }

        // 启动虚拟机的内存管理、系统属性和系统服务的初始配置
        VMRuntime.getRuntime().clearGrowthLimit();
        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);

        // 准备主线程的Looper
        Looper.prepareMainLooper();

        // 加载native服务库
        System.loadLibrary("android_servers");

        // 创建系统上下文并初始化SystemServiceManager
        createSystemContext();
        mSystemServiceManager = new SystemServiceManager(mSystemContext);

    } finally {
        traceEnd();
    }

    // 启动系统服务
    try {
        startBootstrapServices(); // 启动引导服务
        startCoreServices();      // 启动核心服务
        startOtherServices();     // 启动其他服务
    } catch (Throwable ex) {
        throw ex;
    }

    // 启动消息循环
    Looper.loop();
}
```

### **主要步骤解析**

#### **1. 初始化系统环境**

在`run()`方法开始时，`SystemServer`首先设置系统时间、时区、内存管理等参数。通过设置虚拟机堆内存利用率、加载native库等操作，确保系统服务运行的基础环境已经准备好。

#### **2. 准备主线程的Looper**

```java
Looper.prepareMainLooper();
```

`Looper.prepareMainLooper()`用于为系统的主线程准备消息循环机制，等待其它系统服务创建完成后。`Looper.loop()`会启动事件循环，等待消息处理。

#### **3. 创建系统上下文**

```java
createSystemContext();
```

`SystemServer`调用`createSystemContext()`来创建系统的上下文（`Context`），这个`Context`是整个系统服务依赖的上下文，它为各个服务提供系统级别的信息和资源。

#### **4. 启动SystemServiceManager**

```java
mSystemServiceManager = new SystemServiceManager(mSystemContext);
```

`SystemServiceManager`是管理和启动所有系统服务的核心组件。`SystemServer`通过它来启动和管理各个系统服务，并且每个服务在启动时都要向`SystemServiceManager`进行注册。

### **启动系统服务**

`SystemServer`通过三个主要方法来启动系统服务：

#### **1. `startBootstrapServices()`**

`startBootstrapServices()`负责启动系统的引导服务，这是系统启动过程中最基础的服务，包括`ActivityManagerService`、`PowerManagerService`、`DisplayManagerService`等。

```java
private void startBootstrapServices() {
    // 启动ActivityManagerService，管理应用生命周期
    mActivityManagerService = mSystemServiceManager.startService(
            ActivityManagerService.Lifecycle.class).getService();

    // 启动PowerManagerService，管理电源
    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);

    // 启动DisplayManagerService，管理显示
    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);

    // 启动PackageManagerService，管理应用安装、卸载和更新
    mPackageManagerService = PackageManagerService.main(mSystemContext, installer, false, false);
}
```

这些服务是系统启动的基础服务，只有它们启动后，系统才能进行更高级的操作，例如启动用户界面或管理电源。

#### **2. `startCoreServices()`**

`startCoreServices()`负责启动系统的核心服务，包括`BatteryService`、`UsageStatsService`、`WebViewUpdateService`等。

```java
private void startCoreServices() {
    // 启动BatteryService，管理电池状态
    mSystemServiceManager.startService(BatteryService.class);

    // 启动UsageStatsService，统计应用使用情况
    mSystemServiceManager.startService(UsageStatsService.class);

    // 启动WebViewUpdateService，管理WebView更新
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_WEBVIEW)) {
        mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);
    }
}
```

这些核心服务是系统正常运行的重要组成部分，它们负责电池状态监控、应用统计、WebView的管理等功能。

#### **3. `startOtherServices()`**

`startOtherServices()`负责启动系统中的其他服务。这个方法非常复杂，启动了大量的服务，包括输入法、网络管理、音频管理等。

```java
private void startOtherServices() {
    // 启动WindowManagerService，管理窗口
    mWindowManagerService = mSystemServiceManager.startService(WindowManagerService.class);

    // 启动InputManagerService，管理输入
    mInputManagerService = mSystemServiceManager.startService(InputManagerService.class);

    // 启动AudioService，管理音频
    mAudioService = mSystemServiceManager.startService(AudioService.class);

    // 启动NetworkManagementService，管理网络
    mNetworkManagementService = mSystemServiceManager.startService(NetworkManagementService.class);
}
```

这些服务确保Android设备的输入、输出、网络连接等功能正常工作。

### **进入消息循环**

系统服务启动完成后，`SystemServer`调用`Looper.loop()`进入消息循环。此时，系统已经准备好处理来自其他进程或系统事件的消息，开始正常工作。

```java
Looper.loop();
```

此时，`SystemServer`将保持运行，监听和处理各种消息和事件，直到系统关闭。




![image-20250215124518029](./../_pic_/image-20250215124518029.png)

## 00.Android系统结构

- Android系统结构如下图：

  - ![image-20241218163528105](./../_pic_/image-20241218163528105.png)

  

- 首先是概览：Android 底层内核空间以 Linux Kernal 作为基石，上层用户空间由 Native C/C++ 系统库、ART（JAVA虚拟机）、JAVA框架层，应用APP层组成，通过系统调用（Syscall）连通系统的内核空间与用户空间。通过 JNI技术 打通用户空间的 Java 层 和 C++ 层。具体如下：

  - Linux 内核层：Linux 内核层是 Android 体系结构的基石，负责管理底层硬件资源，包括进程调度、内存管理、设备驱动。（也就是cpu管理，内存管理，其它设备资源的管理）
  - 硬件抽象层HAL：不同硬件厂商提供的硬件的驱动不同，而HAL 屏蔽了不同硬件的差异，使得 Android 框架层可以通过统一的接口访问硬件功能，而无须针对不同厂商提供的硬件编写不同的访问代码。
  - Native C/C++ 库 && Android Runtime：
    - 首先什么是库，库是别人编写好的函数，实现对应的功能，这样我们不用重复造轮子。Native C/C++ 库提供了一些核心系统库（如 libc、OpenGL ES、SQLite 等），他们提供了贴近于操作系统底层的功能支持，通过 **JNI（Java Native Interface）** 与 Java/Kotlin 代码交互。Android Runtime（ART）是 Android 的 Java 虚拟机，负责执行 Java 字节码。
  - Java Framework：主要包含Zygote进程，System Server进程。
    - Zygote进程是是由 init 进程通过解析 init.rc 文件后 fork 生成的，其负责启动虚拟机，创建SystemServer进程，预加载系统类和资源（用于提高应用启动速度）。Zygote 还负责孵化新的应用进程。
    - `SystemServer` 是 Zygote 孵化的第一个进程，负责启动和管理整个 Java Framework，包括 ActivityManagerService、WindowManagerService、PackageManagerService、PowerManagerService 等核心系统服务(他们都运行在System Server进程中)。
  - 应用APP层：应用层包括系统内置应用（如 Launcher、Phone、Email 等）和用户安装的第三方应用。它们是由Zygote 进程通过 fork 自身来创建的，第一个由 Zygote 孵化的应用进程通常是 Launcher，即用户看到的桌面应用。应用层负责与用户进行直接交互。

## 01.启动流程概述

- 启动流程如下图：
  - ![image-20241218162217125](./../_pic_/image-20241218162217125.png)
- 简要流程如下：
  - Linux 内核启动时，内核会进行初始化 。在这个过程中，会加载 Binder 驱动，为 Android 的进程间通信提供支持。
  - Native层执行：当内核启动完成后，其会启动 init 进程（pid = 1），这是第一个用户级进程。init 进程是所有用户空间进程的鼻祖，它会解析系统配置文件（init.rc），启动关键系统服务，包括：
    - servicemanager：负责管理 Binder 服务的注册和查询。
    - Zygote 进程：Java 世界的起点，负责孵化应用进程。
  - Java Framework层执行：
    - `Zygote`被Init创建 ，它负责启动Java虚拟机，注册JNI，同时其会创建 `System Server`进程，`System Server` 负责启动和管理整个 Java Framework 层，包括 ActivityManagerService、WindowManagerService 等重要服务。
    - 创建完 `System Server` 之后，Zygote 进程会进入 socket 监听模式，等待创建新的应用进程。所有的应用进程都是由 Zygote 进程 fork 自身而来的。
  - 应用APP层：当用户点击某个应用程序图标时，Launcher 会通过 Binder 机制调用 ActivityManagerService（AMS）。AMS 会通过 socket 与 Zygote 进程通信，请求 Zygote fork 一个新的应用进程。新的应用进程会加载目标应用的 APK 文件，并启动主线程（通常是入口 Activity）。
  - 至此，Android系统开始正式为用户提供服务。

## 02.启动流程源码介绍

- init进程，执行自身的main函数，在执行 `class_start core` 时，init 进程会解析 `init.zygote64_32.rc` 文件，fork 出 app_main 进程并执行 `app_process.cpp` 的 `main` 函数，最终重命名为 Zygote。

- Zygote进程：

  - ```
    app_process.main
        AndroidRuntime.start
            AndroidRuntime.startVm
            AndroidRuntime.startReg
            通过反射机制，获取ZygoteInit.main 方法并执行(首次进入Java世界)
                registerServerSocketFromEnv
                preload
                forkSystemServer
                runSelectLoop
    ```

  - 首先是执行`app_process.main` 函数，创建 AndroidRuntime 实例 runtime ，调用 `runtime .start`，进而调用`AndroidRuntime.startVm`和`AndroidRuntime.startReg`启动 Java 虚拟机并注册 JNI。

  - 通过反射机制调用 `ZygoteInit.main` 方法，正式进入 Java 世界。

    > 这里如何通过反射机制调用 `ZygoteInit.main` 方法？
    >
    > 通过反射调用ZygoteInit类的Main方法:
    >
    > - **根据类名获取ZygoteInit类的jclass对象**：
    >
    >   - ```
    >     char* slashClassName = toSlashClassName(className != NULL ? className : "");
    >     jclass startClass = env->FindClass(slashClassName);
    >     if (startClass == NULL) {
    >         ALOGE("JavaVM unable to locate class '%s'\n", slashClassName);
    >     }
    >     ```
    >
    >   - **toSlashClassName 的作用**：`toSlashClassName` 函数将类名中的点（`.`）替换为斜杠（`/`），因为 JNI 中使用斜杠作为类名的分隔符。
    >
    >   - 通过 `env->FindClass` 方法查找要启动的 Java 类。在 Zygote 启动过程中，传入的类名slashClassName是 `com.android.internal.os.ZygoteInit`，即 `ZygoteInit` 类。
    >
    >   - **提问：jclass是什么**：`jclass` 是 JNI 中的一个类型，表示 Java 类在 JVM 中的本地引用。通过 `env->FindClass` 可以获取到指定类的 `jclass` 对象。
    >
    > - **根据jclass对象查找获取ZygoteInit类的Main方法并执行**：
    >
    >   - ```
    >     // 获取 main 方法的签名（静态方法，参数为 String[]，返回 void）
    >     jmethodID startMeth = env->GetStaticMethodID(startClass, "main", "([Ljava/lang/String;)V");
    >         
    >     // 调用 ZygoteInit.main()
    >     env->CallStaticVoidMethod(startClass, startMeth, strArray);
    >     ```
    >
    >   - `env->GetStaticMethodID` 用于查找指定类的静态方法，并返回该方法的 `jmethodID`。这里用于查找其main方法。
    >
    >   - 如果找到 `main` 方法，那么调用 `CallStaticVoidMethod` 执行这个方法。
    >
    >   - 这意味着，从这里开始，Java 虚拟机会执行 `ZygoteInit` 类中的 `main` 函数，这就是 Android 进入 Java 世界的地方。

  - 在 `ZygoteInit.main` 方法中：

    - `registerServerSocketFromEnv`：创建服务端 Socket，用于接收创建新进程的请求。
    - `preload`：预加载系统类和资源，以提高应用启动速度。（fork 出的子进程会继承 Zygote 的预加载资源，从而加快应用启动速度。）
    - `forkSystemServer`：创建 System Server 进程。
    - `runSelectLoop`：进入 Socket 监听循环，等待创建新进程的请求。

- SystemServer进程：我们上面说到，Zygote进程通过`forkSystemServer`创建 System Server 进程。那么具体是怎样的呢？

  - 整个个调用流程如下:

    - ```
      ZygoteInit.main
      	forkSystemServer
      		Zygote.forkSystemServer()创建进程，创建失败会kill杀死Zygote进程，并在Init中重启
          	handleSystemServerProcess通过类反射机制获取并返回SystemServer.main方法的封装
      	子进程会执行r.run()，运行SystemServer.main方法。
          	SystemServer.run
                  Looper.prepareMainLooper();
                  createSystemContext
                  startBootstrapServices();
                  startCoreServices();
                  startOtherServices();
                  Looper.loop();
      ```

  - 在forkSystemServer函数中调用Zygote.forkSystemServer()创建进程，创建失败会kill杀死Zygote进程，并在Init中重启

    > 这里怎么进行重启的？
    >
    > **如果 `system_server` 进程在运行过程中崩溃或被意外终止，会发送SIGCHLD信号，而`SigChldHandler` 会捕获到这一事件，并通过 `kill(getpid(), SIGKILL)` 杀死 `Zygote` 进程**。这是一个自我保护机制，因为 `system_server` 是 Android 系统中的核心进程，如果它崩溃了，整个系统需要重新启动。
    >
    > **同时一旦 `Zygote` 进程被杀死，系统的父进程 `Init` 会检测到并重启 `Zygote`，从而重新启动 Android 系统。**这份代码逻辑在Init进程的主循环，处理系统事件的部分。

  - 创建成功后，其继续当前代码执行，判断pid = 0，发现自己是SystemServer子进程，于是进入SystemServer子进程的处理逻辑中，首先调用closeServerSocket先关闭“Zygote”socket，因为系统服务进程system_server不用socket，所以close它；

  - 接着调用了handleSystemServerProcess()方法，返回Runnable对象到ZygoteInit.main中，这个ZygoteInit.main不是Zygote进程执行的，而是SystemServer进程执行的，它会在里面判断自己是SystemServer子进程，那么直接在其中通过r.run()调用到com.android.server.SystemServer.main方法。而不会执行Zygote进程执行的方法。

    > 这里怎么找到SystemServer的main方法的？
    >
    > 其实也是通过反射实现的。
    >
    > -  通过反射找到 `com.android.server.SystemServer` 的 `main()` 方法，并将其封装为 `MethodAndArgsCaller`返回给ZygoteInit.main方法中的Runnable对象r。
    > - 当 `r.run()` 被调用时，通过反射实际执行了 `SystemServer.main()`，完成 `system_server` 进程的启动。

  - SystemServer的`main()` 方法首先创建 `SystemServer` 对象，然后调用它的 `run()` 方法，在里面它主要完成了以下几件事情：

    - **准备主线程 Looper**：

    - **加载 `android_servers` 原生库**：

    - **初始化系统上下文**：调用 `createSystemContext()` 方法，创建 `SystemContext`，它是系统服务运行时的上下文环境。

    - **创建 `SystemServiceManager`**：
      - 创建并初始化 `SystemServiceManager`，该类用于管理系统服务的生命周期。

      - 通过 `LocalServices.addService`，将 `SystemServiceManager` 注册到一个静态 `Map`（`LocalServices`）中，便于其他部分调用。


    - **启动系统服务**：
      - 调用一系列方法来启动不同层次的系统服务：
        - `startBootstrapServices()`：启动引导服务。
        - `startCoreServices()`：启动核心服务。
        - `startOtherServices()`：启动其他服务。


    - **进入 `Looper.loop()` 循环**：
      - `Looper.loop()` 方法开启一个无限循环，开始处理主线程的消息队列。
    
      - 这个循环是关键，因为 Android 的大部分服务都是通过消息机制来运作的，它会保持主线程的活跃和响应。

  - 到此, System_server主线程的启动工作总算完成, 进入Looper.loop()状态，等待其他线程通过handler发送消息到主线再处理。

- APP进程：

  - 假设通过startActivity来启动一个新的Activity，而这个Activity附属于一个还未启动的进程，则会启动一个新的进程，调用startActivity的进程通过Binder调用到AMS中的方法，然后经过层层调用，会调用到AMS的Process.start()方法

  - Process类的start()直接调用了ZygoteProcess类的start()方法，该start()方法调用了ZygoteProcess类的startViaZygote()方法

  - 其会在内部上锁调用openZygoteSocketIfNeeded()方法来连接“zygote”Socket，链接Socket成功之后，就会调用zygoteSendArgsAndGetResult()方法来进一步处理。

    > **提问：为什么是socket，而不是binder跟Zygote通信？**
    >
    > 主要是多线程问题，具体来说， `fork()` 只会复制调用它的线程到子进程中，而父进程中的其他线程不会被复制到子进程中，如果父进程在 `fork()` 前是多线程的，且一个线程持有了某个锁，然后另外一个线程调用了fork创建子进程，在子进程中持有那个锁的线程却"蒸发"了，从子进程的角度来看，这个锁被“永久”的上锁了，因为它的持有者“蒸发”了。如果子进程中的任何一个线程对这个已经被持有的锁进行lock操作，就会发生死锁。
    >
    > 

  - openZygoteSocketIfNeeded方法会调用ZygoteState.connect(mSocket);连接Zygote.socket。

  - zygoteSendArgsAndGetResult()方法通过Socket写入流writer把要创建的进程的参数写进去，Zygote的runSelectLoop()方法可以监听到

  - Zygote的runSelectLoop()方法监听到请求后，会进入ZygoteConnection类的processOneCommand()方法，其内部通过Zygote.forkAndSpecialize()来fork新的应用进程

    > forkAndSpecialize如何创建新进程？
    >
    > 1. **停止 Zygote 的其他线程：** 在 `VM_HOOKS.preFork()` 中会停止 Zygote 的其他四个守护线程（用于后台垃圾回收、JIT 编译等），确保在调用 `fork()` 时，Zygote 进程处于单线程状态，从而提高 `fork()` 的效率。同时避免因为多线程下调用 `fork()` 可能导致资源状态的不一致。
    > 2. **调用 `fork()` 函数：** 通过 `nativeForkAndSpecialize()` 方法，Zygote 调用了 C++ 层的 `fork()`，这个操作会创建一个新的子进程。父进程（Zygote）继续运行，而子进程（新的应用进程）从 `fork()` 返回时，返回值为 0。此时从返回时运行，判断为0，代表在子线程中，会进行子线程的初始化。
    > 3. **子进程的初始化：** 如果返回值是 0，意味着在子进程中执行，Zygote 会调用 `handleChildProc()` 对子进程进行初始化。具体步骤包括关闭不必要的文件描述符、挂载虚拟存储设备等。
    > 4. **进入 Java 世界：** 最后，子进程通过 `ZygoteInit.zygoteInit()` 初始化Binder线程池。并最终在后续进入 Java 世界，类似于 `SystemServer` 进程启动流程，应用进程会进入 `ActivityThread.main()`，开始运行 Android 应用的主线程。

  - 创建完成后通过handleChildProc()方法处理，然后流程和上面SystemServer一样，获取主类是ActivityThread.java的main()函数，进入ActivityThread.main()方法后，会创建Application实例



## 03. init进程

- 内核完成启动后，内核会直接启动第一个用户空间程序 init 进程（pid = 1）。然后init进程执行自身的main函数。主要包括如下：
  - 解析 init.rc 配置文件，启动 Android 系统的核心服务。
  - 启动 servicemanager（Binder 机制的核心组件）。
  - 解析 init.zygote64_32.rc 文件，fork 出 app_main 进程并执行 `app_process.cpp` 的 `main` 函数，最终重命名为 Zygote。
  - 进入主循环，监控和重启挂掉的进程。这个在创建System Server失败的时候会执行。
  

### 3.1 init.cpp 中 main函数

- init进程的入口函数是`system/core/init/init.cpp`的main函数，其在用户态主要完成以下任务：

  - 解析init.rc配置文件，启动 Android 系统的核心服务（如 servicemanager、Zygote 等），创建Zygote的工作就是在其中的某个阶段完成的。
  - 进入主循环，重启挂掉的进程。这个在创建System Server失败的时候会执行。
  - 它的代码如下所示：
  
  
  
  - ```c
    int main(int argc, char** argv) {
        add_environment("PATH", _PATH_DEFPATH);
    
        // 第一阶段：内核态
        // 第二阶段：用户态
    
    
        // 解析init.rc
        // ...
    
        while (true) {
            // 默认会休眠直到有事件唤醒
            int epoll_timeout_ms = -1;
    
            if (!(waiting_for_prop || ServiceManager::GetInstance().IsWaitingForExec())) {
                am.ExecuteOneCommand();
            }
            // 重启一些挂掉的进程，例如Zygote
            if (!(waiting_for_prop || ServiceManager::GetInstance().IsWaitingForExec())) {
                restart_processes();
                // If there's a process that needs restarting, wake up in time for that.
                if (process_needs_restart_at != 0) {
                    epoll_timeout_ms = (process_needs_restart_at - time(nullptr)) * 1000;
                    if (epoll_timeout_ms < 0) epoll_timeout_ms = 0;
                }
    
                // If there's more work to do, wake up again immediately.
                if (am.HasMoreCommands()) epoll_timeout_ms = 0;
            }
    
            epoll_event ev;
            int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &ev, 1, epoll_timeout_ms));
            if (nr == -1) {
                PLOG(ERROR) << "epoll_wait failed";
            } else if (nr == 1) {
                ((void (*)()) ev.data.ptr)();
            }
        }
    
        return 0;
    }
    ```
  
- 下面给出 init.rc 部分内容(Mi Max3--MIUI 10--Android 9)：

  - ```
    on early-init
    on init
    .........
    on post-fs-data  // mount /data/
        // 启动 logd
        start logd
        // 启动 vold, 用于管理Android外部存储介质的后台进程，包括SD卡的插拔等
        start vold
        // ...
    // ...
    on boot
        // ...
        class_start core
    ```
    
  - Zygote 的启动是在 class_start core启动核心类的时候执行的。具体是通过解析 `init.zygote64_32.rc` 文件完成的。


### 3.2 Class_start core

在 `class_start core` 时，init 进程会解析 `init.zygote64_32.rc` 文件，fork 出 app_main 进程并执行 `app_process.cpp` 的 `main` 函数，最终重命名为 Zygote。

补充：下面是 init.zygote64_32.rc 文件：

```shell
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote
    class main
    priority -20
    user root
    group root readproc reserved_disk
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media
    onrestart restart netd
    onrestart restart wificond
    writepid /dev/cpuset/foreground/tasks
```



## 04. Zygote进程

`Zygote`被Init创建 ，它负责

- 启动Java虚拟机，注册JNI
- 同时其会创建 `System Server`进程。

- 在创建完 `System Server` 之后，Zygote 进程会进入 socket 监听模式，等待创建新的应用进程。所有的应用进程都是由 Zygote 进程 fork 自身而来的，因此 Zygote 被称为 Java 世界的“女娲”。


### 4.1 概述

随着init解析完成init.zygote64_32.rc ，fork出 app_main 进程执行 app_process.cpp的main函数。整个调用流程如下:

```shell
app_process.main
    AndroidRuntime.start
        AndroidRuntime.startVm
        AndroidRuntime.startReg
        通过反射机制，获取ZygoteInit.main 方法并执行(首次进入Java世界)
            registerServerSocketFromEnv
            preload
            forkSystemServer
            runSelectLoop
```

Zygote进程共做了如下几件事：

1. init 进程解析 `init.zygote64_32.rc` 文件，fork 出 app_main 进程并执行 `app_process.cpp` 的 `main` 函数。
2. `app_process.main` 调用 `AndroidRuntime.start`，进而调用`AndroidRuntime.startVm`和`AndroidRuntime.startReg`启动 Java 虚拟机并注册 JNI。
3. 通过反射机制调用 `ZygoteInit.main` 方法，正式进入 Java 世界。
4. 在 `ZygoteInit.main` 方法中：
   - `registerServerSocketFromEnv`：创建服务端 Socket，用于接收创建新进程的请求。
   - `preload`：预加载系统类和资源，以提高应用启动速度。（fork 出的子进程会继承 Zygote 的预加载资源，从而加快应用启动速度。）
   - `forkSystemServer`：创建 System Server 进程。
   - `runSelectLoop`：进入 Socket 监听循环，等待创建新进程的请求。

### 4.1 app_main.cpp

Zygote本身是一个Native的应用程序，和驱动、内核等均无关系。zygote最初的名字叫“app_process”，但app_process在运行过程中，通过Linux下的prctl系统调用将自己的名字换成了“zygote”

zygote的原型app_process所对应的源文件是`frameworks/base/cmds/app_process/app_main.cpp`，代码如下所示：

```cpp
int main(int argc, const char* const argv[])
{
    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));

    // --zygote : Start in zygote mode
    // --start-system-server : Start the system server.
    // --application : Start in application (stand alone, non zygote) mode.
    // --nice-name : The nice name for this process.
    bool zygote = false;
    bool startSystemServer = false;
    bool application = false;
    String8 niceName;
    String8 className;

    while (i < argc) {
        const char* arg = argv[i++];
        if (strcmp(arg, "--zygote") == 0) {
            zygote = true;
            niceName = ZYGOTE_NICE_NAME;  // zygote64 or zygote
        } else if (strcmp(arg, "--start-system-server") == 0) {
            startSystemServer = true;
        } else if (strcmp(arg, "--application") == 0) {
            application = true;
        } else if (strncmp(arg, "--nice-name=", 12) == 0) {
            niceName.setTo(arg + 12);
        } else if (strncmp(arg, "--", 2) != 0) {
            className.setTo(arg);
            break;
        } else {
            --i;
            break;
        }
    }

    Vector<String8> args;
    if (!className.isEmpty()) {
        // We're not in zygote mode
        // 需要传递给RuntimeInit的唯一参数是application参数，剩余的args传递给启动类main
        args.add(application ? String8("application") : String8("tool"));
        runtime.setClassNameAndArgs(className, argc - i, argv + i);
    } else {
        // We're in zygote mode.
        maybeCreateDalvikCache();

        if (startSystemServer) {
            args.add(String8("start-system-server"));
        }

        char prop[PROP_VALUE_MAX];
        if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) {
            LOG_ALWAYS_FATAL("app_process: Unable to determine ABI list from property %s.",
                ABI_LIST_PROPERTY);
            return 11;
        }

        String8 abiFlag("--abi-list=");
        abiFlag.append(prop);
        args.add(abiFlag);

        // In zygote mode, pass all remaining arguments to the zygote
        // main() method.
        for (; i < argc; ++i) {
            args.add(String8(argv[i]));
        }
    }

    if (!niceName.isEmpty()) {
        runtime.setArgv0(niceName.string(), true /* setProcName */);
    }

    if (zygote) {
        runtime.start("com.android.internal.os.ZygoteInit", args, zygote);
    } else if (className) {
        runtime.start("com.android.internal.os.RuntimeInit", args, zygote);
    } else {
        fprintf(stderr, "Error: no class name or --zygote supplied.\n");
        app_usage();
        LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied.");
    }
}

```

上面代码有两个关键函数

```
AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));

runtime.start
```

- 这个创建了一个 `AppRuntime` 对象 `runtime`，它是`AppRuntime` 是 `AndroidRuntime` 的子类，负责启动 Android 应用程序的运行时环境（ART 或 Dalvik）。

-  runtime.start 函数使用的是基类AndroidRuntime的start。


### 4.2 AndroidRuntime.start

```C++
// frameworks/base/core/jni/AndroidRuntime.cpp
void AndroidRuntime::start(const char* className, const Vector<String8>& options, bool zygote)
{
    const char* rootDir = getenv("ANDROID_ROOT");
    if (rootDir == NULL) {
        rootDir = "/system";
        if (!hasDir("/system")) {
            LOG_FATAL("No root directory specified, and /android does not exist.");
            return;
        }
        setenv("ANDROID_ROOT", rootDir, 1);
    }

    /* start the virtual machine */
    JniInvocation jni_invocation;
    jni_invocation.Init(NULL);
    JNIEnv* env;
    if (startVm(&mJavaVM, &env, zygote) != 0) {
        return;
    }
    onVmCreated(env);

    // 因为后续Java世界用到的一些函数是采用native方式来实现的，所以必须提前注册这些函数
    if (startReg(env) < 0) {
        ALOGE("Unable to register all android natives\n");
        return;
    }

    // 将参数封装到strArray里

    /*
     * Start VM.  This thread becomes the main thread of the VM, and will
     * not return until the VM exits.
     */
    char* slashClassName = toSlashClassName(className != NULL ? className : "");
    jclass startClass = env->FindClass(slashClassName);
    if (startClass == NULL) {
        ALOGE("JavaVM unable to locate class '%s'\n", slashClassName);
    } else {
        // 找到ZygoteInit类的static main函数的jMethodId
        jmethodID startMeth = env->GetStaticMethodID(startClass, "main",
            "([Ljava/lang/String;)V");
        if (startMeth == NULL) {
            ALOGE("JavaVM unable to find main() in '%s'\n", className);
        } else {
            // 调用ZygoteInit.main函数后，Zygote便进入了Java世界
            env->CallStaticVoidMethod(startClass, startMeth, strArray);
        }
    }
    free(slashClassName);
}
```

- **启动 Java 虚拟机**：

  - ```
    if (startVm(&mJavaVM, &env, zygote) != 0) {
        return;
    }
    onVmCreated(env);
    ```

  - `startVm` 函数负责启动 Java 虚拟机，并初始化 `mJavaVM`（JavaVM 实例）和 `env`（JNIEnv 指针）。如果虚拟机启动成功，会调用 `onVmCreated(env)` 执行一些虚拟机初始化后的操作。


- **注册 Android 原生函数**：

  - ```
    if (startReg(env) < 0) {
        ALOGE("Unable to register all android natives\n");
        return;
    }
    ```

  - `startReg` 函数负责注册 Android 系统的 JNI 原生函数，即将 C++ 的方法与 Java 的 native 方法进行绑定。这些原生函数是 Android 框架层与 Native 层交互的关键。

  - **怎么理解：将 C++ 的方法和 Java 方法进行绑定**
    - 在 Java 中使用 `native` 关键字声明一个本地方法。
    - 通过 `System.loadLibrary` 加载包含 native 方法实现的共享库（如 `.so` 文件）。
    - 在 C/C++ 中实现与 Java native 方法对应的函数，并通过 JNI 注册机制将其绑定到 Java 方法。。

- 通过反射调用ZygoteInit类的Main方法:

   - **根据类名获取ZygoteInit类的jclass对象**：

      - ```
         char* slashClassName = toSlashClassName(className != NULL ? className : "");
         jclass startClass = env->FindClass(slashClassName);
         if (startClass == NULL) {
             ALOGE("JavaVM unable to locate class '%s'\n", slashClassName);
         }
         ```

      - **toSlashClassName 的作用**：`toSlashClassName` 函数将类名中的点（`.`）替换为斜杠（`/`），因为 JNI 中使用斜杠作为类名的分隔符。

      - 通过 `env->FindClass` 方法查找要启动的 Java 类。在 Zygote 启动过程中，传入的类名slashClassName是 `com.android.internal.os.ZygoteInit`，即 `ZygoteInit` 类。

      - **提问：jclass是什么**：`jclass` 是 JNI 中的一个类型，表示 Java 类在 JVM 中的本地引用。通过 `env->FindClass` 可以获取到指定类的 `jclass` 对象。

   - **根据jclass对象查找获取ZygoteInit类的Main方法并执行**：

     - ```
       jmethodID startMeth = env->GetStaticMethodID(startClass, "main",
           "([Ljava/lang/String;)V");
       if (startMeth == NULL) {
           ALOGE("JavaVM unable to find main() in '%s'\n", className);
       } else {
           env->CallStaticVoidMethod(startClass, startMeth, strArray);
       }
       ```

     - `env->GetStaticMethodID` 用于查找指定类的静态方法，并返回该方法的 `jmethodID`。这里用于查找其main方法。

     - 如果找到 `main` 方法，那么调用 `CallStaticVoidMethod` 执行这个方法。

     - 这意味着，从这里开始，Java 虚拟机会执行 `ZygoteInit` 类中的 `main` 函数，这就是 Android 进入 Java 世界的地方。


### 4.3 ZygoteInit.main

-  `CallStaticVoidMethod` 最终将调用ZygoteInit类的main函数。

- 此时Zygote正式进入到了自身的Java侧，开始执行自身的使命：创建SystemServer，fork应用程序。

- 代码如下所示：

  ```
  // frameworks/base/core/java/com/android/internal/os/ZygoteInit.java
  public static void main(String argv[]) {
      ZygoteServer zygoteServer = new ZygoteServer();
      try {
          boolean startSystemServer = false;
          String socketName = "zygote";
          String abiList = null;
          boolean enableLazyPreload = false;
          for (int i = 1; i < argv.length; i++) {
              if ("start-system-server".equals(argv[i])) {
                  startSystemServer = true;
              } else if ("--enable-lazy-preload".equals(argv[i])) {
                  enableLazyPreload = true;
              } else if (argv[i].startsWith(ABI_LIST_ARG)) {
                  abiList = argv[i].substring(ABI_LIST_ARG.length());
              } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {
                  socketName = argv[i].substring(SOCKET_NAME_ARG.length());
              } else {
                  throw new RuntimeException("Unknown command line argument: " + argv[i]);
              }
          }
          // 创建一个Zygote的Socket接口，用来和AMS等通信
          zygoteServer.registerServerSocketFromEnv(socketName);
          if (!enableLazyPreload) {
              // 预加载一些类和资源，这是导致Android系统启动慢的原因之一
              // 应用程序都从Zygote孵化出来，应用程序都会继承Zygote的所有内容，如果在Zygote启动的时候加载这些类和资源，
              // 这些孵化的应用程序就继承Zygote的类和资源，这样启动引用程序的时候就不需要加载类和资源了，启动的速度就会快很多。
              preload(bootTimingsTraceLog);
          }
  
          // Do an initial gc to clean up after startup
          gcAndFinalize();
  
          if (startSystemServer) {
              Runnable r = forkSystemServer(abiList, socketName, zygoteServer);
              // 子进程（system_server）
              if (r != null) {
                  // 调用com.android.server.SystemServer.main方法
                  r.run();
                  return;
              }
          }
  
          Log.i(TAG, "Accepting command socket connections");
  
          // The select loop returns early in the child process after a fork and
          // loops forever in the zygote.
          caller = zygoteServer.runSelectLoop(abiList);
      } catch (Throwable ex) {
          Log.e(TAG, "System zygote died with exception", ex);
          throw ex;
      } finally {
          zygoteServer.closeServerSocket();
      }
  
      // We're in the child process and have exited the select loop. Proceed to execute the command.
      if (caller != null) {
          caller.run();
      }
  }
  ```

  - 摘选其中重要的代码

  - ```
    // 创建一个Zygote的Socket接口，用来和AMS等通信
        zygoteServer.registerServerSocketFromEnv(socketName);
        if (!enableLazyPreload) {
            // 预加载一些类和资源，这是导致Android系统启动慢的原因之一
            // 应用程序都从Zygote孵化出来，应用程序都会继承Zygote的所有内容，如果在Zygote启动的时候加载这些类和资源，
            // 这些孵化的应用程序就继承Zygote的类和资源，这样启动引用程序的时候就不需要加载类和资源了，启动的速度就会快很多。
            preload(bootTimingsTraceLog);
        }
        
        
         if (startSystemServer) {
            Runnable r = forkSystemServer(abiList, socketName, zygoteServer);
            // 子进程（system_server）
            if (r != null) {
                // 调用com.android.server.SystemServer.main方法
                r.run();
                return;
            }
        }
        
        caller = zygoteServer.runSelectLoop(abiList);
    ```

- 上面有三个重要的调用：

  - registerServerSocketFromEnv用来注册一个 Zygote Server 套接字，用来和AMS等系统服务通信

  - `preload()` 方法用于预加载系统类和资源。由于 Android 应用都通过 Zygote 进程孵化而来，预加载有助于加快应用程序启动速度。

  - `forkSystemServer()` 方法用于创建 `system_server` 进程。创建成功则返回一个 `Runnable`对象，里面是通过反射封装的SystemServer.main()方法，fork完成后，SystemServer进程从fork之后继续执行，通过`r.run()`执行自身 `SystemServer.main()`方法。

  - `runSelectLoop()` 是 Zygote 的主循环，监听 Zygote 套接字，等待来自 AMS 等服务的进程启动请求。


## 05. system_server进程

### 5.1 概述

整个调用流程:

```shell
ZygoteInit.main
	forkSystemServer
		Zygote.forkSystemServer()创建进程，创建失败会kill杀死Zygote进程，并在Init中重启
    	handleSystemServerProcess通过类反射机制获取并返回SystemServer.main方法的封装，这个过程会创建binder线程池
	子进程会执行r.run()，运行SystemServer.main方法。
    	SystemServer.run
            Looper.prepareMainLooper();
            createSystemContext
            startBootstrapServices();
            startCoreServices();
            startOtherServices();
            Looper.loop();
```

SyetemServer在启动时做了如下工作：

1. 启动Binder线程池，这样就可以与其他进程进行通信。
2. 创建SystemServiceManager用于对系统的服务进行创建、启动和生命周期管理。
3. 启动各种系统服务。AMS，PMS，以及WMS等都是运行在system_server这个进程中的线程。
4. 执行loop循环等待消息到来。

### 5.2 ZygoteInit.forkSystemServer

在上节中，ZygoteInit.main方法首次进入Java世界，然后调用了forkSystemServer方法创建system_server进程。

```Java
private static Runnable forkSystemServer(String abiList, String socketName,
        ZygoteServer zygoteServer) {
    /* Hardcoded command line to start the system server */
    String args[] = {
        "--setuid=1000",
        "--setgid=1000",
        "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1024,1032,1065,3001,3002,3003,3006,3007,3009,3010",
        "--capabilities=" + capabilities + "," + capabilities,
        "--nice-name=system_server",
        "--runtime-args",
        "--target-sdk-version=" + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,
        "com.android.server.SystemServer",
    };
    ZygoteConnection.Arguments parsedArgs = null;

    int pid;

    try {
        parsedArgs = new ZygoteConnection.Arguments(args);
        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);
        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);

        boolean profileSystemServer = SystemProperties.getBoolean(
                "dalvik.vm.profilesystemserver", false);
        if (profileSystemServer) {
            parsedArgs.runtimeFlags |= Zygote.PROFILE_SYSTEM_SERVER;
        }

        /* Request to fork the system server process */
        pid = Zygote.forkSystemServer(
                parsedArgs.uid, parsedArgs.gid,
                parsedArgs.gids,
                parsedArgs.runtimeFlags,
                null,
                parsedArgs.permittedCapabilities,
                parsedArgs.effectiveCapabilities);
    } catch (IllegalArgumentException ex) {
        throw new RuntimeException(ex);
    }

    /* For child process */
    if (pid == 0) {
        if (hasSecondZygote(abiList)) {
            waitForSecondaryZygote(socketName);
        }

        zygoteServer.closeServerSocket();
        return handleSystemServerProcess(parsedArgs);
    }

    return null;
}
```

在这里设置了system_server进程的各种权限（如 UID、GID、组权限等）。

实际的线程创建是通过Zygote.forkSystemServer()函数执行。

这里有两个重要的调用：

- Zygote.forkSystemServer()函数用来fork一个新的进程，如果pid==0，表示已经进入SystemServer子进程，于是先关闭“Zygote”socket，因为系统服务进程system_server不用socket，所以close它；
- 调用了handleSystemServerProcess()方法，返回Runnable对象到ZygoteInit.main中，并在其中通过r.run()调用到com.android.server.SystemServer.main方法。

因此我们后续有三个重要函数要看，一个是Zygote.forkSystemServer，一个是handleSystemServerProcess,一个是SystemServer.main



### 5.3 Zygote.forkSystemServer

首先看看Zygote.forkSystemServer方法，它调用的是nativeForkSystemServer方法，该方法定义在 C++ 文件 `Zygote.cpp` 中，它接收 UID、GID 等系统参数，并负责 fork 出一个新的 `system_server` 进程。

```C++
// frameworks/base/core/jni/com_android_internal_os_Zygote.cpp
static jint com_android_internal_os_Zygote_nativeForkSystemServer(
        JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,
        jint runtime_flags, jobjectArray rlimits, jlong permittedCapabilities,
        jlong effectiveCapabilities) {
    pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids,
                                        runtime_flags, rlimits,
                                        permittedCapabilities, effectiveCapabilities,
                                        MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL,
                                        NULL, NULL, NULL);
    if (pid > 0) {
    }
    return pid;
}

static pid_t ForkAndSpecializeCommon(/* ... */) {
    SetSignalHandlers();
    pid_t pid = fork(); // fork子进程
    UnsetChldSignalHandler();
}

static void SetSignalHandlers() {
    struct sigaction sig_chld = {};
    sig_chld.sa_handler = SigChldHandler;

    if (sigaction(SIGCHLD, &sig_chld, NULL) < 0) {
        ALOGW("Error setting SIGCHLD handler: %s", strerror(errno));
    }

    struct sigaction sig_hup = {};
    sig_hup.sa_handler = SIG_IGN;
    if (sigaction(SIGHUP, &sig_hup, NULL) < 0) {
        ALOGW("Error setting SIGHUP handler: %s", strerror(errno));
    }
}

// Sets the SIGCHLD handler back to default behavior in zygote children.
static void UnsetChldSignalHandler() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = SIG_DFL;

    if (sigaction(SIGCHLD, &sa, NULL) < 0) {
        ALOGW("Error unsetting SIGCHLD handler: %s", strerror(errno));
    }
}

static void SigChldHandler(int /*signal_number*/) {
    pid_t pid;
    int status;

    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
        if (pid == gSystemServerPid) {
            ALOGE("Exit zygote because system server (%d) has terminated", pid);
            kill(getpid(), SIGKILL);
        }
    }
}
```

在这里进行了SystemServer进程的实际fork操作，

同时有一个值得注意的：**如果 `system_server` 进程在运行过程中崩溃或被意外终止，会发送SIGCHLD信号，而`SigChldHandler` 会捕获到这一事件，并通过 `kill(getpid(), SIGKILL)` 杀死 `Zygote` 进程**。这是一个自我保护机制，因为 `system_server` 是 Android 系统中的核心进程，如果它崩溃了，整个系统需要重新启动。

**同时一旦 `Zygote` 进程被杀死，系统的父进程 `Init` 会检测到并重启 `Zygote`，从而重新启动 Android 系统。**这份代码逻辑在Init进程的主循环，处理系统事件的部分。

### 5.4 handleSystemServerProcess

```Java
private static Runnable handleSystemServerProcess(ZygoteConnection.Arguments parsedArgs) {
    ClassLoader cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);
    Thread.currentThread().setContextClassLoader(cl);
    return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);
}

public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) {
    // 执行Binder驱动程序初始化的相关工作，它调用之后system_server进程就可以进行Binder进程通信
    ZygoteInit.nativeZygoteInit();
    return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);
}

// frameworks/base/core/java/com/android/internal/os/RuntimeInit.java
protected static Runnable applicationInit(int targetSdkVersion, String[] argv,
        ClassLoader classLoader) {
    final Arguments args = new Arguments(argv);
    return findStaticMain(args.startClass, args.startArgs, classLoader);
}

// 通过反射获得com.android.server.SystemServer的main方法
protected static Runnable findStaticMain(String className, String[] argv,
        ClassLoader classLoader) {
    Class<?> cl = Class.forName(className, true, classLoader);
    Method m = cl.getMethod("main", new Class[] { String[].class });
    return new MethodAndArgsCaller(m, argv);
}

static class MethodAndArgsCaller implements Runnable {
    /** method to call */
    private final Method mMethod;

    /** argument array */
    private final String[] mArgs;

    public MethodAndArgsCaller(Method method, String[] args) {
        mMethod = method;
        mArgs = args;
    }

    public void run() {
        mMethod.invoke(null, new Object[] { mArgs });
    }
}
```

- `handleSystemServerProcess` 首先创建了 `system_server` 进程的类加载器，然后调用 `ZygoteInit.zygoteInit` 方法。
- 在 `zygoteInit` 方法中，会创建Binder线程池，使 `system_server` 能进行进程间通信。
- 之后，`RuntimeInit.applicationInit` 通过反射找到 `com.android.server.SystemServer` 的 `main()` 方法，并将其封装为 `MethodAndArgsCaller`返回给ZygoteInit.main方法中的Runnable对象r。
- 当 `r.run()` 被调用时，通过反射实际执行了 `SystemServer.main()`，完成 `system_server` 进程的启动。

到这里可以知道ZygoteInit.main方法中的`Runnable r = forkSystemServer(abiList, socketName, zygoteServer);`返回的r即是MethodAndArgsCaller，在子进程中调用r.run方法便是调用了com.android.server.SystemServer.main方法。



### 5.5 SystemServer#main

```Java
// SystemServer.java
public final class SystemServer {
    ...
    public static void main(String[] args) {
        //先初始化SystemServer对象，再调用对象的run()方法
        new SystemServer().run();
    }
}

private void run() {
    Looper.prepareMainLooper();// 准备主线程looper

    //加载android_servers.so库，该库包含的源码在frameworks/base/services/目录下
    System.loadLibrary("android_servers");

    createSystemContext(); //初始化系统上下文

    //创建系统服务管理
    mSystemServiceManager = new SystemServiceManager(mSystemContext);
    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);

    //启动各种系统服务
    try {
        startBootstrapServices(); // 启动引导服务
        startCoreServices();      // 启动核心服务
        startOtherServices();     // 启动其他服务
    } catch (Throwable ex) {
        throw ex;
    }

    //一直循环执行
    Looper.loop();
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
```

`main()` 方法首先创建 `SystemServer` 对象，然后调用它的 `run()` 方法：

在`run()` 方法中它主要完成了以下几件事情：

1. **准备主线程 Looper**：

2. **加载 `android_servers` 原生库**：

3. **初始化系统上下文**：调用 `createSystemContext()` 方法，创建 `SystemContext`，它是系统服务运行时的上下文环境。

4. **创建 `SystemServiceManager`**：

   - 创建并初始化 `SystemServiceManager`，该类用于管理系统服务的生命周期。

   - 通过 `LocalServices.addService`，将 `SystemServiceManager` 注册到一个静态 `Map`（`LocalServices`）中，便于其他部分调用。


5. **启动系统服务**：
   - 调用一系列方法来启动不同层次的系统服务：
     - `startBootstrapServices()`：启动引导服务。
     - `startCoreServices()`：启动核心服务。
     - `startOtherServices()`：启动其他服务。


5. **进入 `Looper.loop()` 循环**：

   - `Looper.loop()` 方法开启一个无限循环，开始处理主线程的消息队列。

   - 这个循环是关键，因为 Android 的大部分服务都是通过消息机制来运作的，它会保持主线程的活跃和响应。


具体调用关系如下：

```Java
SystemServer.main
    SystemServer.run
        Looper.prepareMainLooper();
        createSystemContext
        startBootstrapServices();
        startCoreServices();
        startOtherServices();
        Looper.loop();
```



首先看看启动引导服务的方法startBootstrapServices：

```Java
private void startBootstrapServices() {
    // 阻塞等待与installd建立socket通道
    Installer installer = mSystemServiceManager.startService(Installer.class);

    // In some cases after launching an app we need to access device identifiers,
    // therefore register the device identifier policy before the activity manager.
    mSystemServiceManager.startService(DeviceIdentifiersPolicyService.class);

    mActivityManagerService = mSystemServiceManager.startService(
            ActivityManagerService.Lifecycle.class).getService();
    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);
    mActivityManagerService.setInstaller(installer);

    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);
    mActivityManagerService.initPowerManagement();

    mSystemServiceManager.startService(RecoverySystemService.class);

    // Now that we have the bare essentials of the OS up and running, take
    // note that we just booted, which might send out a rescue party if
    // we're stuck in a runtime restart loop.
    RescueParty.noteBoot(mSystemContext);

    mSystemServiceManager.startService(LightsService.class);

    // Package manager isn't started yet; need to use SysProp not hardware feature
    if (SystemProperties.getBoolean("config.enable_sidekick_graphics", false)) {
        mSystemServiceManager.startService(WEAR_SIDEKICK_SERVICE_CLASS);
    }

    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);

    // We need the default display before we can initialize the package manager.
    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);

    // 当设备正在加密时，仅运行core apps
    String cryptState = SystemProperties.get("vold.decrypt");
    if (ENCRYPTING_STATE.equals(cryptState)) {
        Slog.w(TAG, "Detected encryption in progress - only parsing core apps");
        mOnlyCore = true;
    } else if (ENCRYPTED_STATE.equals(cryptState)) {
        Slog.w(TAG, "Device encrypted - only parsing core apps");
        mOnlyCore = true;
    }

    // Start the package manager.
    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,
            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);
    mFirstBoot = mPackageManagerService.isFirstBoot();
    mPackageManager = mSystemContext.getPackageManager();

    mSystemServiceManager.startService(UserManagerService.LifeCycle.class);

    AttributeCache.init(mSystemContext);

    // Set up the Application instance for the system process and get started.
    mActivityManagerService.setSystemProcess();

    mDisplayManagerService.setupSchedulerPolicies();
    mSystemServiceManager.startService(new OverlayManagerService(mSystemContext, installer));

    // 启动传感器服务
    startSensorService();
```

该方法所创建的服务：ActivityManagerService, PowerManagerService, LightsService, DisplayManagerService， PackageManagerService， UserManagerService， sensor服务等。

然后是启动核心服务startCoreServices：

```Java
private void startCoreServices() {
    // 启动服务BatteryService，用于统计电池电量，需要LightService.
    mSystemServiceManager.startService(BatteryService.class);

    // 启动服务UsageStatsService，用于统计应用使用情况
    mSystemServiceManager.startService(UsageStatsService.class);
    mActivityManagerService.setUsageStatsManager(
            LocalServices.getService(UsageStatsManagerInternal.class));

    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_WEBVIEW)) {
        // 启动服务WebViewUpdateService
        mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);
    }

    BinderCallsStatsService.start();
}
```

启动服务BatteryService，UsageStatsService，WebViewUpdateService等。

启动其它服务的startOtherServices方法比较长，主要是启动一系列的服务：

```Java
private void startOtherServices() {
    // ...
    ServiceManager.addService("sec_key_att_app_id_provider", new KeyAttestationApplicationIdProviderService(context));
    mSystemServiceManager.startService(KeyChainSystemService.class);
    ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
    mSystemServiceManager.startService(TelecomLoaderService.class);
    telephonyRegistry = new TelephonyRegistry(context);
    ServiceManager.addService("telephony.registry", telephonyRegistry);
    mEntropyMixer = new EntropyMixer(context);

    mContentResolver = context.getContentResolver();

    mSystemServiceManager.startService(ACCOUNT_SERVICE_CLASS);
    mSystemServiceManager.startService(CONTENT_SERVICE_CLASS);

    // 准备好window, power, package, display服务
    wm.systemReady();
    mPowerManagerService.systemReady(...);
    mPackageManagerService.systemReady();
    mDisplayManagerService.systemReady(...);
    mActivityManagerService.systemReady(...);
    // ...
}
```

重要的有

**WindowManagerService (WMS)**：负责管理窗口，处理 UI 显示、窗口层级、应用之间的 UI 切换等操作。

**ContentService**：提供数据共享和内容提供者（Content Provider）管理功能，允许应用程序访问和共享数据。



到此, System_server主线程的启动工作总算完成, 进入Looper.loop()状态，等待其他线程通过handler发送消息到主线再处理。



## 06. App进程

### 6.1 app进程发送请求

ActivityManagerService也是由SystemServer创建的。

假设通过startActivity来启动一个新的Activity，而这个Activity附属于一个还未启动的进程，则会启动一个新的进程，调用startActivity的进程通过Binder调用到ActivityManagerService中的方法，然后经过层层调用，会调用到ActivityManagerService的Process.start()方法，代码如下所示：

```Java
public static final ProcessStartResult start(final String processClass,
                                  final String niceName,
                                  int uid, int gid, int[] gids,
                                  int runtimeFlags, int mountExternal,
                                  int targetSdkVersion,
                                  String seInfo,
                                  String abi,
                                  String instructionSet,
                                  String appDataDir,
                                  String invokeWith,
                                  String[] zygoteArgs) {
    return zygoteProcess.start(processClass, niceName, uid, gid, gids,
            runtimeFlags, mountExternal, targetSdkVersion, seInfo,
            abi, instructionSet, appDataDir, invokeWith, zygoteArgs);
}
```

这里的参数processClass为“android.app.ActivityThread”，它是传进去的第一个参数，也就是程序初始化进程时要加载的主文件Java类。当应用进程启动之后，会把这个类加载到进程，调用它的main()方法作为应用程序进程的入口。

### 6.2 AMS发送请求

Process类的start()直接调用了ZygoteProcess类的start()方法，该start()方法调用了ZygoteProcess类的startViaZygote()方法，下面看看该方法实现：

```C++
private Process.ProcessStartResult startViaZygote(final String processClass, final String niceName,
    final int uid, final int gid, final int[] gids, int runtimeFlags, int mountExternal, 
    int targetSdkVersion, String seInfo, String abi, String instructionSet,String appDataDir, 
    String invokeWith, String[] extraArgs) throws ZygoteStartFailedEx {
    ArrayList<String> argsForZygote = new ArrayList<String>();
    argsForZygote.add("--runtime-args");
    argsForZygote.add("--setuid=" + uid);
    argsForZygote.add("--setgid=" + gid);
    // ......
    synchronized(mLock) {
        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
    }
}
```

首先给它设置值，包括uid、gid等。接着上锁，调用openZygoteSocketIfNeeded()方法来连接“zygote”Socket，链接Socket成功之后，就会调用zygoteSendArgsAndGetResult()方法来进一步处理。

**提问：为什么是socket，而不是binder跟Zygote通信？**

主要是多线程问题，具体来说， `fork()` 只会复制调用它的线程到子进程中，而父进程中的其他线程不会被复制到子进程中，如果父进程在 `fork()` 前是多线程的，且一个线程持有了某个锁，然后另外一个线程调用了fork创建子进程，在子进程中持有那个锁的线程却"蒸发"了，从子进程的角度来看，这个锁被“永久”的上锁了，因为它的持有者“蒸发”了。如果子进程中的任何一个线程对这个已经被持有的锁进行lock操作，就会发生死锁。



先来看看openZygoteSocketIfNeeded()方法：

```Java
private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {
    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {
        try {
            primaryZygoteState = ZygoteState.connect(mSocket);
        }
}
```

方法中的mSocket的值是“zygote”，通过connect()方法去连接“zygote”Socket。接着看看zygoteSendArgsAndGetResult()方法：

```Java
private static Process.ProcessStartResult zygoteSendArgsAndGetResult(
        ZygoteState zygoteState, ArrayList<String> args)
        throws ZygoteStartFailedEx {
    try {
        final BufferedWriter writer = zygoteState.writer;
        final DataInputStream inputStream = zygoteState.inputStream;
        writer.write(Integer.toString(args.size()));
        writer.newLine();
        for (int i = 0; i < sz; i++) {
            String arg = args.get(i);
            writer.write(arg);
            writer.newLine();
        }
        writer.flush();
}
```

通过Socket写入流writer把前面传过来的那些参数写进去，Socket即ZygoteServer类的runSelectLoop()方法监听。写入这些数据之后，ZygoteServer类的runSelectLoop()方法就能被监听到。

### 6.3 Zygote响应请求

这是Zygote的runSelectLoop，监听事件循环

```Java
void setForkChild() {
    mIsForkChild = true;
}

Runnable runSelectLoop(String abiList) {
    ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();
    ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();

    fds.add(mServerSocket.getFileDescriptor());
    peers.add(null);

    while (true) {
        StructPollfd[] pollFds = new StructPollfd[fds.size()];
        for (int i = 0; i < pollFds.length; ++i) {
            pollFds[i] = new StructPollfd();
            pollFds[i].fd = fds.get(i);
            pollFds[i].events = (short) POLLIN;
        }
        try {
            Os.poll(pollFds, -1);
        } catch (ErrnoException ex) {
            throw new RuntimeException("poll failed", ex);
        }
        for (int i = pollFds.length - 1; i >= 0; --i) {
            if ((pollFds[i].revents & POLLIN) == 0) {
                continue;
            }

            if (i == 0) {
                ZygoteConnection newPeer = acceptCommandPeer(abiList);
                peers.add(newPeer);
                fds.add(newPeer.getFileDesciptor());
            } else {
                try {
                    ZygoteConnection connection = peers.get(i);
                    final Runnable command = connection.processOneCommand(this);
                    // 通过mIsForkChild变量控制父进程接着死循环/子进程返回command
                    if (mIsForkChild) {
                        // We're in the child. We should always have a command to run at this
                        // stage if processOneCommand hasn't called "exec".
                        if (command == null) {
                            throw new IllegalStateException("command == null");
                        }

                        return command;
                    } else {
                        // We're in the server - we should never have any commands to run.
                        if (command != null) {
                            throw new IllegalStateException("command != null");
                        }

                        if (connection.isClosedByPeer()) {
                            connection.closeSocket();
                            peers.remove(i);
                            fds.remove(i);
                        }
                    }
                } catch (Exception e) {
                    if (!mIsForkChild) {
                        ZygoteConnection conn = peers.remove(i);
                        conn.closeSocket();
                        fds.remove(i);
                    } else {

                        throw e;
                    }
                } finally {
                    mIsForkChild = false;
                }
            }
        }
    }
}
```

监听到请求后，会进入ZygoteConnection类的processOneCommand()方法：

```Java
Runnable processOneCommand(ZygoteServer zygoteServer) {
    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
            parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
            parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.instructionSet,
            parsedArgs.appDataDir);
    try {
        if (pid == 0) {
            // in child
            zygoteServer.setForkChild();
            zygoteServer.closeServerSocket();
            IoUtils.closeQuietly(serverPipeFd);
            serverPipeFd = null;
            return handleChildProc(parsedArgs, descriptors, childPipeFd);
        }
    }
}
```

- 此处通过Zygote.forkAndSpecialize()来fork新的应用进程，而启动systemserver进程是通过Zygote.forkSystemServer()来fork SystemServer进程。
- 此处通过handleChildProc()方法处理，而之前是用handleSystemServerProcess()来处理。

通过fork新的应用程序进程之后，返回pid等于0就表示进入子进程，于是调用handleChildProc()方法进一步处理：

```Java
private Runnable handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors,FileDescriptor pipeFd) {
    // ZygoteInit.zygoteInit中会创建Binder线程池，
    // 也就是说每个进程无论是否包含任何activity等组件，一定至少会包含一个Binder线程
    return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,null /* classLoader */);
}
```

到此处，后面便和上面一样的了，唯一不同的是，SystemServer进程启动之后进入的是主类SystemServer.java的main()函数，而这里应用程序启动起来后进入的是主类是ActivityThread.java的main()函数，进入ActivityThread.main()方法后，会创建Application实例。

接下来就只剩下forkAndSpecialize方法的解析了：

调用逻辑很复杂，我们简要概括为以下几个重要步骤：

1. **停止 Zygote 的其他线程：** 在 `VM_HOOKS.preFork()` 中会停止 Zygote 的其他四个守护线程（用于后台垃圾回收、JIT 编译等），确保在调用 `fork()` 时，Zygote 进程处于单线程状态，从而提高 `fork()` 的效率。同时避免因为多线程下调用 `fork()` 可能导致资源状态的不一致。
2. **调用 `fork()` 函数：** 通过 `nativeForkAndSpecialize()` 方法，Zygote 调用了 C++ 层的 `fork()`，这个操作会创建一个新的子进程。父进程（Zygote）继续运行，而子进程（新的应用进程）从 `fork()` 返回时，返回值为 0。此时从返回时运行，判断为0，代表在子线程中，会进行子线程的初始化。
3. **子进程的初始化：** 如果返回值是 0，意味着在子进程中执行，Zygote 会调用 `handleChildProc()` 对子进程进行初始化。具体步骤包括关闭不必要的文件描述符、挂载虚拟存储设备等。
4. **进入 Java 世界：** 最后，子进程通过 `ZygoteInit.zygoteInit()` 初始化Binder线程池。并最终在后续进入 Java 世界，类似于 `SystemServer` 进程启动流程，应用进程会进入 `ActivityThread.main()`，开始运行 Android 应用的主线程。

## 07.总结

具体流程如下图

![image-20241218162404642](./../_pic_/image-20241218162404642.png)

   

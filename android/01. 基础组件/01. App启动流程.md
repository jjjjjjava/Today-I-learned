



### 1. **启动应用所属的进程**

`Zygote` 解析参数并通过 `fork()` 创建新的进程，然后在新的进程中通过反射机制加载 `ActivityThread` 类并调用其 `main()` 方法。

### 2. **ActivityThread的main方法**

当新的应用进程被启动后，`Zygote` fork 出来的进程会执行 `ActivityThread.main()` 方法，这是应用进程的入口。

```
java复制代码public static void main(String[] args) {
    // 初始化主线程环境，包括设置进程名和初始化主线程Looper
    Process.setArgV0("<pre-initialized>");
    Looper.prepareMainLooper();
    
    // 创建 ActivityThread 实例
    ActivityThread thread = new ActivityThread();
    thread.attach(false); // 绑定 ActivityManagerService

    // 启动主线程的消息循环
    Looper.loop();
}
```

#### **主线程 Looper 的初始化**

`Looper.prepareMainLooper()` 方法初始化了主线程的 `Looper`，并关联主线程的 `MessageQueue`，这也是为什么我们可以在主线程中创建 `Handler` 的原因——因为主线程有一个已经初始化的 `Looper`，用于管理消息循环。

#### **创建 ActivityThread 实例**

`ActivityThread` 是应用进程的核心，它管理应用生命周期、Activity 栈、以及与系统的通信。在 `main()` 方法中，创建了一个 `ActivityThread` 实例，并通过 `attach()` 方法将应用进程与 `ActivityManagerService` 进行绑定。

### 3. **ActivityThread的attach方法**

`attach()` 方法主要用于绑定应用进程和 `ActivityManagerService`。

```
java复制代码private void attach(boolean system) {
    final IActivityManager mgr = ActivityManagerNative.getDefault();
    try {
        // 通过 Binder 通信，通知 AMS 该应用已经启动
        mgr.attachApplication(mAppThread);
    } catch (RemoteException ex) {
        // 处理异常
    }
}
```

`attach()` 通过 `Binder` 机制调用了 `ActivityManagerService` 的 `attachApplication()` 方法，通知系统该应用进程已经启动。此时，应用进程已经准备好与系统服务通信。

### 4. **ActivityManagerService的attachApplication方法**

`ActivityManagerService` 在接收到应用的启动通知后，会执行一系列初始化操作，并调用应用的 `bindApplication()` 方法来进行应用级别的初始化。

```
java复制代码@Override
public final void attachApplication(IApplicationThread thread) {
    synchronized (this) {
        int callingPid = Binder.getCallingPid();
        attachApplicationLocked(thread, callingPid);
    }
}
```

`attachApplication()` 方法会进一步调用 `attachApplicationLocked()`，其中涉及了加载应用的资源、初始化 `ActivityStackSupervisor` 等一系列操作。最终，它会调用 `ActivityThread.ApplicationThread` 的 `bindApplication()`。

### 5. **ActivityThread.ApplicationThread的bindApplication方法**

`bindApplication()` 方法是 `ActivityThread` 用于初始化应用环境的关键步骤，它通过 `AppBindData` 传递应用信息和配置，并且将这些信息应用到应用上下文中。

```
java复制代码public final void bindApplication(String processName, ApplicationInfo appInfo, ...) {
    // 设置系统服务缓存
    ServiceManager.initServiceCache(services);

    // 保存应用绑定数据
    AppBindData data = new AppBindData();
    data.processName = processName;
    data.appInfo = appInfo;
    data.providers = providers;

    // 发送 BIND_APPLICATION 消息
    sendMessage(H.BIND_APPLICATION, data);
}
```

通过发送 `BIND_APPLICATION` 消息，`ActivityThread` 将初始化逻辑推迟到消息处理时执行。消息被发送到主线程的 `MessageQueue`，等待后续的处理。

### 6. **handleBindApplication方法**

`handleBindApplication()` 方法是应用进程正式初始化的地方，关键步骤包括设置应用进程名、创建 `Context` 实例、加载 `Application` 类并执行其 `onCreate()` 方法。

```
java复制代码private void handleBindApplication(AppBindData data) {
    // 设置进程名
    Process.setArgV0(data.processName);

    // 创建应用上下文
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);

    // 通过反射创建 Application 实例并调用 onCreate()
    Application app = data.info.makeApplication(data.restrictedBackupMode, null);
    app.onCreate();
}
```

#### **创建 ContextImpl**

`ContextImpl` 是 `Context` 的具体实现类，它为应用程序提供系统资源访问、启动服务、发送广播等功能。在 `handleBindApplication()` 中，`ContextImpl` 被创建并作为应用的上下文。

#### **创建 Application 实例并调用 onCreate()**

`data.info.makeApplication()` 通过反射机制创建应用的 `Application` 实例，并调用其 `onCreate()` 方法，至此，应用的初始化过程基本完成，应用进入到可以处理用户逻辑的状态。

### 7. **Application的onCreate()方法**

`Application` 类的 `onCreate()` 是应用进程初始化完成后，开发者可以自定义行为的地方。此时，应用已经创建了上下文，系统服务可以正常工作，开发者可以在 `onCreate()` 中执行初始化逻辑，如依赖注入、网络库初始化等。

```
java复制代码@Override
public void onCreate() {
    super.onCreate();
    // 应用初始化逻辑
}
```

### **总结**

1. **启动流程**：应用进程的启动从 `ActivityManagerService` 发起，通过 `Zygote` 进程的 fork，最终执行 `ActivityThread.main()`，进入应用的主线程。
2. **初始化过程**：`ActivityThread.main()` 方法初始化了主线程的消息循环，并通过 `attach()` 绑定到 `ActivityManagerService`，然后通过 `bindApplication()` 进行应用初始化。
3. **应用环境的创建**：在 `handleBindApplication()` 中，创建了 `ContextImpl` 作为应用的 `Context`，并通过反射机制加载应用的 `Application` 类，调用 `onCreate()` 方法。





## 代码


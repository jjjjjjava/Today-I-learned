[toc]

## Handler消息机制

### Handler消息机制的基本概念

在Android开发中，**Handler** 是非常重要的工具，它主要用于在不同线程之间进行消息传递和处理，特别是在子线程中更新UI时，Handler 是必不可少的。Android的主线程（UI线程）是单线程的，不能直接进行多线程操作，例如从子线程更新UI。因此，Handler消息机制在Android的线程管理和消息处理机制中起着重要作用。

#### Handler的两个主要功能：

1. **计划消息或任务在未来的某个时间执行**：可以通过Handler将一个消息（`Message`）或者一个可运行的任务（`Runnable`）发送到某个线程的消息队列（`MessageQueue`）中，并在指定的时间处理它们。
2. **跨线程处理代码**：子线程可以通过Handler将消息传递给主线程，主线程接收到消息后可以执行相关的处理逻辑。



### MessageQueue

`MessageQueue` 是一个消息队列，用于存储消息（`Message`）对象。它采用链表结构，消息按执行时间顺序排列。

#### `enqueueMessage()` 方法：

```
java复制代码boolean enqueueMessage(Message msg, long when) {
    if (msg.target == null) {
        throw new IllegalArgumentException("Message must have a target.");
    }

    synchronized (this) {
        Message p = mMessages;
        if (p == null || when < p.when) {
            // 插入到队列头
            msg.next = p;
            mMessages = msg;
        } else {
            // 插入到合适的位置，保持时间顺序
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when < p.when) {
                    break;
                }
            }
            msg.next = p;
            prev.next = msg;
        }
    }
    return true;
}
```

`MessageQueue`通过该方法将消息按触发时间的顺序插入到队列中，`MessageQueue`中存储的所有消息都会按照时间先后顺序出队。

#### `next()` 方法：

```
java复制代码Message next() {
    int nextPollTimeoutMillis = 0;

    for (;;) {
        nativePollOnce(ptr, nextPollTimeoutMillis);  // 阻塞，等待消息

        synchronized (this) {
            final long now = SystemClock.uptimeMillis();
            Message msg = mMessages;
            if (msg != null && now >= msg.when) {
                mMessages = msg.next;
                msg.next = null;
                return msg;
            }

            nextPollTimeoutMillis = -1;  // 没有消息，继续阻塞
        }
    }
}
```

该方法从消息队列中取出一条消息，如果没有消息则会阻塞，直到有新消息到来。

### Looper

`Looper`是Android消息机制中的核心组件，它与 `MessageQueue` 绑定，通过 `loop()` 方法不断地从消息队列中取出消息并进行处理。

#### `prepare()` 方法

在创建 `Handler` 之前，线程必须通过 `Looper.prepare()` 来初始化Looper，主线程已经自动初始化，因此子线程需要显式调用。

```
java复制代码public static void prepare() {
    sThreadLocal.set(new Looper());
}
```

每个线程只能调用一次 `prepare()`，通过 `ThreadLocal` 来保证 `Looper` 对象在线程中的唯一性。

#### `loop()` 方法

`loop()` 是消息循环的核心，它会不断从 `MessageQueue` 中取出消息并分发给对应的 `Handler`。

```
java复制代码public static void loop() {
    Looper me = myLooper();
    MessageQueue queue = me.mQueue;

    for (;;) {
        Message msg = queue.next(); // 可能会阻塞
        if (msg == null) {
            return;
        }

        msg.target.dispatchMessage(msg); // 调用 Handler 的 dispatchMessage 处理消息
        msg.recycleUnchecked(); // 回收消息对象
    }
}
```

该方法不断从 `MessageQueue` 中取消息，并通过 `msg.target.dispatchMessage(msg)` 将消息交给目标 `Handler` 处理。

### Handler的消息分发

当 `Looper` 从 `MessageQueue` 中取出消息后，会调用 `Handler.dispatchMessage()` 进行消息的分发。该方法根据消息类型调用不同的处理方法。

```
java复制代码public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        msg.callback.run();
    } else {
        if (mCallback != null && mCallback.handleMessage(msg)) {
            return;
        }
        handleMessage(msg); // 默认的消息处理
    }
}
```

消息处理优先级：

1. 如果 `msg.callback` 不为空，则调用 `Runnable.run()`。
2. 如果 `Handler` 的 `mCallback` 不为空，则调用 `mCallback.handleMessage()`。
3. 否则，调用 `Handler.handleMessage()`，这是最常用的处理方式。

### Message

`Message` 是Android消息机制中消息的封装类，它的主要字段包括：

- `what`：消息的标识。
- `arg1` 和 `arg2`：可以携带的简单数据。
- `obj`：可以携带的对象数据。
- `target`：处理该消息的 `Handler`。

消息通常通过 `Message.obtain()` 方法来获取，而不是直接通过构造函数创建，`obtain()` 方法会从消息池中取出一个可用的消息对象，避免重复创建。

```
java复制代码public static Message obtain() {
    synchronized (sPoolSync) {
        if (sPool != null) {
            Message m = sPool;
            sPool = m.next;
            m.next = null;
            sPoolSize--;
            return m;
        }
    }
    return new Message();
}
```

### 总结

- **Handler** 是Android中用于发送和处理消息的工具，它与 `Looper` 和 `MessageQueue` 密切配合工作。`Handler` 通过 `Looper` 将消息发送到对应的 `MessageQueue`，并在消息到达时由 `Looper` 分发给 `Handler` 处理。
- **MessageQueue** 是一个存储消息的队列，采用链表结构存储消息，按照消息的执行时间进行排序。消息的出队和入队操作通过 `enqueueMessage()` 和 `next()` 方法来完成。
- **Looper** 是消息循环的核心，它不断从 `MessageQueue` 中取消息并调用 `Handler` 处理消息。每个线程只能有一个 `Looper`，主线程的 `Looper` 在程序启动时自动创建。
- **Message** 是消息的载体，携带需要处理的数据，通过 `Message.obtain()` 获取实例，避免重复创建对象。

通过这些组件的配合，Android 实现了线程间的消息通信，确保了子线程与主线程之间的任务调度和数据传递。

## 怎么理解：主线程是单线程的

### 1. **什么是Android的主线程（UI线程）？**

在Android应用中，**主线程**（有时也称为**UI线程**）是负责处理用户界面（UI）更新和与用户交互的线程。它是应用程序启动时由系统自动创建的，管理应用程序的生命周期、事件（例如点击、触摸）处理、绘制界面、响应用户操作等。

**主线程的核心职责**：

- 处理Android的**UI绘制**。
- 管理用户的**输入事件**（如触摸、点击）。
- 处理**Activity**和**Fragment**的生命周期回调。
- 保证所有UI相关的任务都在主线程上运行。

### 2. **为什么主线程是单线程模型？**

Android的UI框架设计为**单线程模型**，意味着**所有与UI相关的操作都必须在主线程上执行**。这是因为UI组件并不是线程安全的，如果多个线程同时操作UI组件，可能会产生不可预期的结果，导致应用崩溃或UI更新混乱。

主线程是单线程的，具体表现为：

- 只有一个线程负责更新UI和响应用户操作，避免了多线程访问共享资源（UI组件）带来的复杂性。
- Android框架通过这种设计来简化开发者处理UI的工作，同时避免并发问题。

**举个例子**：如果一个按钮在两个线程中同时被操作，线程A正在更改按钮的文本，线程B同时修改了按钮的背景色。这种情况下，如果线程调度不确定，可能会导致UI渲染出错，甚至引发崩溃。

### 3. **子线程不能直接更新UI的原因**

Android 强制规定**UI只能在主线程更新**，原因如下：

- **线程安全**：Android的UI框架并不是线程安全的。如果多个线程同时修改UI组件，可能导致并发冲突。例如，一个线程可能会更改视图的状态，而另一个线程可能会在视图还未完成更改时尝试读取它，导致错误和崩溃。
- **主线程的事件循环**：主线程运行着一个事件循环（`Looper`），负责不断从消息队列中读取并处理事件（例如用户输入、系统事件等），并执行UI更新。子线程没有这个事件循环机制，因此它无法正确管理和执行UI操作。

### 4. **为什么需要多线程？**

虽然UI线程是单线程的，但实际应用中，我们经常会进行一些耗时操作，如网络请求、文件读取、复杂的计算等。如果这些耗时操作放在主线程中执行，会导致主线程被阻塞，应用响应变慢，甚至**ANR（Application Not Responding）**，即“应用无响应”错误。

因此，Android开发中，我们常常将耗时任务放在**子线程**中执行，确保主线程能够专注于UI更新和用户交互，保持界面流畅。然而，子线程不能直接操作UI，因此当任务完成时，必须通过某种方式通知主线程更新UI。

### 5. **子线程更新UI的错误例子**

如果你尝试在子线程中直接更新UI，Android会抛出异常。看一个例子：

```
java复制代码new Thread(new Runnable() {
    @Override
    public void run() {
        // 子线程试图更新UI
        textView.setText("子线程直接更新UI");
    }
}).start();
```

这段代码会抛出`CalledFromWrongThreadException`，因为子线程不允许直接修改UI。

### 6. **正确的做法：使用Handler或其他方式切换到主线程**

为了让子线程执行完任务后安全地更新UI，Android提供了多种方式让你把UI更新的操作**切换回主线程**。

#### 1. **使用Handler**

`Handler` 是最常用的方式之一，可以从子线程发送消息到主线程进行UI更新。

```
java复制代码Handler handler = new Handler(Looper.getMainLooper()); // 主线程Handler

new Thread(new Runnable() {
    @Override
    public void run() {
        // 执行耗时任务

        // 回到主线程更新UI
        handler.post(new Runnable() {
            @Override
            public void run() {
                textView.setText("任务完成，更新UI");
            }
        });
    }
}).start();
```